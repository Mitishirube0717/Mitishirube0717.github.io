[{"title":"2024.10月份考试总结","url":"/2024/10/01/10%E6%9C%88%E4%BB%BD%E6%A8%A1%E6%8B%9F%E8%B5%9B%E6%80%BB%E7%BB%93/","content":" 2024.10.3：\n能够感受到出题人深深的恶意，扔了道 zak 没场切的交互，甚至 2e5 的输出关同步流被卡了。\n A：\n一共只有25n25 n25n种本质不同的操作，不妨求出每种操作后的新串的平方子串个数，最后取其中最大值即可。 跨过它们的平方子串（包括修改后新生成的）的贡献。\n记L=min⁡(LCS(a,b)，len),R=min⁡(LCP(a+1,b+1)，len−1)L=\\min (L C S(a, b) ，len  ), R=\\min (L C P(a+1, b+1) ，len -1 )L=min(LCS(a,b)，len),R=min(LCP(a+1,b+1)，len−1)，贡献为max⁡(0,L+R−k+1)\\max (0, L+R-k+1)max(0,L+R−k+1)。\n至于有修改的情况，不妨先考虑每种修改对L,RL, RL,R分别造成了什么影响。下以RRR为例说明，设修改了第iii个点：\ni∈[1,a]:Ri \\in[1, a]: Ri∈[1,a]:R保持不变；\ni∈[a+1,a+R],Ri \\in[a+1, a+R], Ri∈[a+1,a+R],R变为i−(a+1)i-(a+1)i−(a+1)。\ni=a+R+1i=a+R+1i=a+R+1：若将sa+R+1s_{a+R+1}sa+R+1​修改为sb+R+1，Rs_{b+R+1} ， Rsb+R+1​，R变为R+1+LCP(a+R+2,b+R+2)R+1+L C P(a+R+2, b+R+2)R+1+LCP(a+R+2,b+R+2)；否则，仍为RRR。\nmax⁡(0,L+R−k+1)\\max (0, L+R-k+1)max(0,L+R−k+1)取哪一边，可以得到更细致的分类，每一类中的贡献都是一个关于iii的一次函数。\n于是只要对贡献数组做O(1)O(1)O(1)次区间加一次函数，差分即可。\n B：\n官解：\n考虑三角剖分的对偶图 (去掉外部无限大的面对应的那个点) ，可以发现该对偶图构成一棵树。\n并且，若以原图中边(1,n)(1, n)(1,n)所在的三角形为树的根，则其是一棵有根二叉树。\n我们不妨将其视为一棵二叉搜索树。\n在此建模中，可以发现，题面中的一次操作对二叉树形态的影响，相当于二叉树中的一次左旋/右旋操作。\n同时，注意到点xxx为题面中的&quot;关键点&quot;，等价于二叉树的根的左子树大小为x−2x-2x−2。\n于是，若要使xxx成为关键点，只要将中序遍历中第x−1x-1x−1个点通过旋转操作转到根即可。\n这可以使用 splay 做到均摊O((n+m)log⁡n)O((n+m) \\log n)O((n+m)logn)次旋转操作。\n C：\n考虑一个长为n−1n-1n−1的排列插入nnn，有nnn种方式，且其对逆序对数的影响恰分别为+0,+1,+2,…,+(n−1)+0,+1,+2, \\ldots,+(n-1)+0,+1,+2,…,+(n−1)。\n使用生成函数，得到长为nnn，逆序对数为mmm的排列数为：\n[xm]∏i=1n1−xi1−x=[xm]∏i=1n(1−xi)(1−x)n\\left[x^{m}\\right] \\prod_{i=1}^{n} \\frac{1-x^{i}}{1-x}=\\left[x^{m}\\right] \\frac{\\prod_{i=1}^{n}\\left(1-x^{i}\\right)}{(1-x)^{n}}\n[xm]i=1∏n​1−x1−xi​=[xm](1−x)n∏i=1n​(1−xi)​\n由于m≤nm \\leq nm≤n，所以∏i=1n(1−xi)≡∏i=1∞(1−xi)( mod xm+1)\\prod_{i=1}^{n}\\left(1-x^{i}\\right) \\equiv \\prod_{i=1}^{\\infty}\\left(1-x^{i}\\right)\\left(\\bmod x^{m+1}\\right)∏i=1n​(1−xi)≡∏i=1∞​(1−xi)(modxm+1)。\n考虑五边形数定理（这辈子没想到会用这个）：\nF(x)=∏i=1∞(1−xi)=1+∑i=1∞(−1)ixi(3i+1)2F(x)=\\prod_{i=1}^{\\infty}\\left(1-x^{i}\\right)=1+\\sum_{i=1}^{\\infty}(-1)^{i} x^{\\frac{i(3 i+1)}{2}}\nF(x)=i=1∏∞​(1−xi)=1+i=1∑∞​(−1)ix2i(3i+1)​\n于是答案转化为[xm]F(x)(1−x)n\\left[x^{m}\\right] \\frac{F(x)}{(1-x)^{n}}[xm](1−x)nF(x)​。\n由于FFF在前mmm项中只有O(m)O(\\sqrt{m})O(m​)项是非 0 的，可以做到O(m)O(\\sqrt{m})O(m​)求解单次询问的答案，总时间复杂度O(n+Tm)O(n+T \\sqrt{m})O(n+Tm​)。\n\n 2024.10.5：\n A：\n任意染色的总方案是mnm^{n}mn，但存在本质相同的方案。考虑怎样的染色会等致本质相同，首先需要找到点的对应关系使原图同构。\n因为原图为基环树，为了使对应后每条边仍合法，可知若环上点不与自己对应，只可能是将原图绕环旋些后新图与原图满足同构，考虑怎样求出最小旋转距离。\n设环上总点数为lenl e nlen。为满足旋转后环上每点连出的树同构，先对每棵树进行树hash。\n对于 hash值相等的所有树，找出它们在环上的间距，若间距均相等 (设为ddd) 则原图每旋转ddd这些树就会同构，若间距不等就只有旋转 len (即转回原图) 后这些树才会同构。\n求出不同 hash值所需的旋转长度的 lcm，即可得到整个图的最小旋转距离（设为 D）。\n现在已知所有合法的点的对应倩况，考虑统计染色方案。已知使图能同构的最小旋转距离DDD，可将环上每DDD个点及连出树归为一部分，共T=len/DT=l e n / DT=len/D部分。\n每部分内的染色不会相互影响，只需算出该部分内所有树的不同构染色方案数相乘就得到每一部分的染色方案，可在树hash 同时用组合数求得。因为每部分都互相同构，染色方案都相同，设为fff。\n考虑用容斥计算最终本质不同的方案数，若每部分染色方案均不同，则答案应为fTT\\frac{f^{T}}{T}TfT​，因为每种本质相同的染色方案都在fTf^{T}fT中算入了TTT次。\n但因存在一些部分染色方案相同，可能导致这种本质相同的染色方案并没有没算够TTT次。\n若染色方案由长为KKK的循环串重复T/KT / KT/K次后得到，则fTf^{T}fT中它只被计入了KKK次。\n从大到小枚举TTT的因数KKK，考虑将当前钦定偱环串长为KKK的本质相同染色方案补至TTT次，钦定循环串长为KKK的染色方案即为fKf^{K}fK。\n在之前枚举的KKK的倍数tKt KtK时，每次染色都会令其出现KKK次，因此只需用TK\\frac{T}{K}KT​减去所有tKt KtK的系数a[tK]a[t K]a[tK]之和即可得到当前的fKf^{K}fK的系数a[K]a[K]a[K]。\n将所有fKf^{K}fK系数算出来后相乘相加最后除TTT就得到本质不同的染色方案。\n B：\n建 SAM，用总的本质不同字符串对数减去存在包含关系的。\n不妨枚举大串，计算为其子串的不同个数，为了避免算重，在大串第一次出现位置统计答案。\n一个字符串所有子串第一次出现位置可以用插入每个前缀的lenp−lenfapl e n_{p}-l e n_{f a_{p}}lenp​−lenfap​​刻画，即s1…p,s2…p,…,slenp−lenfap…ps_{1 \\ldots p}, s_{2 \\ldots p}, \\ldots, s_{l e n_{p}}-l e n_{f a p} \\ldots ps1…p​,s2…p​,…,slenp​​−lenfap​…p，左端点为一段前缀。\n设l=lenp−lenfapl=l e n_{p}-l e n_{f a_{p}}l=lenp​−lenfap​​，最后一次左端点出现在lll之后的字符串显然可以和这lll个字符串配对，否则可以和左端点位置个配对，注意减去重复的。\n问题变为计算[l+1,p][l+1, p][l+1,p]的本质不同子串个数以及[1,l][1, l][1,l]的本质不同子串个数的左端点之和，二者本质相同。对 parent tree 上每个点维护上一次被标记的最右端点，每次更新s[i…p]s[i \\ldots p]s[i…p]的所有右端点等价于把ppp到根路径上区间赋值，显然可以把一条链上相同的标记一起考虑做一次区间加，这等价于 LCT 中 access 操作，直接上 LCT 即可。\n随便用什么东西维护左端点的信息就完事了。\n C：\n先考虑L∈[l,r],R=rL \\in[l, r], R=rL∈[l,r],R=r，即询问区间的所有后缀的贡献。\n模拟一个左端点L=rL=rL=r，然后往前移动的过程，过程中维护最大值，并贡献答案。\n对于每个点，找出其左边第一个大于它的点，这样的关系构成了树，并且上述过程中最大值的变化过程构成了一条向上的链。\n记[L,R][L, R][L,R]最大值为sps_{p}sp​，则这条链从RRR开始，到ppp结束，发现链上的点，除了ppp之外的点的贡献是可以预处理的，点xxx的贡献为sx×(x−fax)s_{x} \\times\\left(x-f a_{x}\\right)sx​×(x−fax​)。\n于是可以预处理树上前缀和之后再差分，对于ppp的贡献单独处理，L∈[l,r],R=rL \\in[l, r], R=rL∈[l,r],R=r的部分贡献为sum⁡R−sum⁡p+sp×(p−L+1)\\operatorname{sum}_{R}-\\operatorname{sum}_{p}+s_{p} \\times(p-L+1)sumR​−sump​+sp​×(p−L+1)。\n发现对于L∈[l,r],R=rL \\in[l, r], R=rL∈[l,r],R=r的部分，贡献只与最大值处有关。仔细思考一下，在解决一个[L,R][L, R][L,R]的问题时，也可以视作只关注了最大值处，所以理论上，解决单个区间的复杂度与解决后缀区间的复杂度是几乎一致的。\n于是只需要求出区间最大值的位置，就可以O(1)O(1)O(1)计算答案了。\n 2024.10.7：\n A：\n考虑用 ‘rxxx’ 填充矩阵，可以将位置2和4替换为 y，这样除了边上的 y 都可以提供 3 的贡献，共 38193=2166，算上边上的共 2166+19*3=2223 ，优先填 3，最后用 1 补齐即可。\n B：\n考虑二分答案 mid，我们只关注学生能否使得被抓人数≤\\leq≤mid。\n那么，所有人数≤mid\\leq m i d≤mid的实验室就无关紧要了，只关心人数为a&gt;mida&gt;m i da&gt;mid的实验室，设同学有ppp的概率进入这个实验室，那么如果老师选择进入这个实验室，期望抓到的人数就是(1−p)×a。 (1-p) \\times a_{\\text {。 }}(1−p)×a。 ​\n所以我们要求对于任意这样的aia_{i}ai​，都有(1−pi)×ai≤mid\\left(1-p_{i}\\right) \\times a_{i} \\leq m i d(1−pi​)×ai​≤mid，据此可以求出每个pip_{i}pi​的下界，全加起来看看到不到 1即可。\n C：\n？\n D：\n诶呦是原。\n 2024.10.8：\n A：\n设dpi,j,kd p_{i, j, k}dpi,j,k​表示序列aaa的前iii个数，最大值为jjj，并且前iii个数里有kkk个jjj的合法方案数，那么dpi,j,kd p_{i, j, k}dpi,j,k​可以转移到dpi+1,j,k,dpi+1,j,k+1,dpi+1,x,1(x&gt;j)d p_{i+1, j, k}, d p_{i+1, j, k+1}, d p_{i+1, x, 1}(x&gt;j)dpi+1,j,k​,dpi+1,j,k+1​,dpi+1,x,1​(x&gt;j)。\n容易发现k≤bjk \\leq b_{j}k≤bj​，所以状态总数是O(n2)O\\left(n^{2}\\right)O(n2)级别的，加上前缀和可以做到O(n2)O\\left(n^{2}\\right)O(n2)。\n B：\n将式子转化一下：\n(x mod y)×y=(x−⌊xy⌋×y)×y=−⌊xy⌋×y2+x×y(x \\bmod y) \\times y=\\left(x-\\left\\lfloor\\frac{x}{y}\\right\\rfloor \\times y\\right) \\times y=-\\left\\lfloor\\frac{x}{y}\\right\\rfloor \\times y^{2}+x \\times y\n(xmody)×y=(x−⌊yx​⌋×y)×y=−⌊yx​⌋×y2+x×y\n这是一个关于yyy的二次函数，开口向下，所以最大值决策在x[2y]×2\\frac{x}{\\left[\\frac{2}{y}\\right] \\times 2}[y2​]×2x​的前驱后继之中，整除分块使得⌊xy⌋\\left\\lfloor\\frac{x}{y}\\right\\rfloor⌊yx​⌋为定值后查询区间前驱后继，可以做到预处理后O(1)O(1)O(1)查询。\n容易发现这个东西可以线段树维护，复杂度为nnlog⁡nn \\sqrt{n} \\log nnn​logn，可以通过n≤105n \\leq 10^{5}n≤105的部分分。\n因为我们有O(n)O(n)O(n)次修改，O(nn)O(n \\sqrt{n})O(nn​)次查询，所以我们希望均摊后能做到O(n)O(\\sqrt{n})O(n​)修改，O(1)O(1)O(1)查询。考虑对值域分块，维护每一个值块内的前驱后继，散块可以直接查询，整块可以暴力查询，因为整除分块之后得到的区间是不交的，所以一个整块只会被暴力查询一次，复杂度是O(nn)O(n \\sqrt{n})O(nn​)。\n C:\n将斐波那契转化为通项公式形式：\nfi=15((1+52)i−(1−52)i)f_{i}=\\frac{1}{\\sqrt{5}}\\left(\\left(\\frac{1+\\sqrt{5}}{2}\\right)^{i}-\\left(\\frac{1-\\sqrt{5}}{2}\\right)^{i}\\right)\nfi​=5​1​⎝⎛​(21+5​​)i−(21−5​​)i⎠⎞​\n令A=15,B=−15,x=1+52,y=1−52A=\\frac{1}{\\sqrt{5}}, B=-\\frac{1}{\\sqrt{5}}, x=\\frac{1+\\sqrt{5}}{2}, y=\\frac{1-\\sqrt{5}}{2}A=5​1​,B=−5​1​,x=21+5​​,y=21−5​​，那么有\nfi=Axi+Byif_{i}=A x^{i}+B y^{i}\nfi​=Axi+Byi\n这是一个普通幂的形式，跟组合数的下降幂不太搭，观察到kkk比较小，考虑使用斯特林数把下降幂转化成普通幂:\nfik=∑j=0k(−1)k−j[kj]fijf_{i}^{k}=\\sum_{j=0}^{k}(-1)^{k-j}\\left[\\begin{array}{l}\nk \\\\\nj\n\\end{array}\\right] f_{i}^{j}\nfik​=j=0∑k​(−1)k−j[kj​]fij​\n于是\n 原式 ×k!=∑i=lr∑j=0k(−1)k−j[kj](Axi+Byi)j=∑j=0k(−1)k−j[kj]∑i=lr(Axi+Byi)j=∑j=0k(−1)k−j[kj]∑i=lr∑p=0j(jp)ApxipBj−pyi(j−p)=∑j=0k(−1)k−j[kj]∑p=0j(jp)ApBj−p∑i=lrxipyi(j−p)\\begin{aligned}\n\\text { 原式 } \\times k! &amp; =\\sum_{i=l}^{r} \\sum_{j=0}^{k}(-1)^{k-j}\\left[\\begin{array}{l}\nk \\\\\nj\n\\end{array}\\right]\\left(A x^{i}+B y^{i}\\right)^{j} \\\\\n&amp; =\\sum_{j=0}^{k}(-1)^{k-j}\\left[\\begin{array}{l}\nk \\\\\nj\n\\end{array}\\right] \\sum_{i=l}^{r}\\left(A x^{i}+B y^{i}\\right)^{j} \\\\\n&amp; =\\sum_{j=0}^{k}(-1)^{k-j}\\left[\\begin{array}{l}\nk \\\\\nj\n\\end{array}\\right] \\sum_{i=l}^{r} \\sum_{p=0}^{j}\\binom{j}{p} A^{p} x^{i p} B^{j-p} y^{i(j-p)} \\\\\n&amp; =\\sum_{j=0}^{k}(-1)^{k-j}\\left[\\begin{array}{l}\nk \\\\\nj\n\\end{array}\\right] \\sum_{p=0}^{j}\\binom{j}{p} A^{p} B^{j-p} \\sum_{i=l}^{r} x^{i p} y^{i(j-p)}\n\\end{aligned}\n 原式 ×k!​=i=l∑r​j=0∑k​(−1)k−j[kj​](Axi+Byi)j=j=0∑k​(−1)k−j[kj​]i=l∑r​(Axi+Byi)j=j=0∑k​(−1)k−j[kj​]i=l∑r​p=0∑j​(pj​)ApxipBj−pyi(j−p)=j=0∑k​(−1)k−j[kj​]p=0∑j​(pj​)ApBj−pi=l∑r​xipyi(j−p)​\n最后一个∑\\sum∑里面的东西使用等比数列求和即可。\n但是发现 5 在模109+710^{9}+7109+7意义下并没有二次剩余，所以需要手写一个。\n时间复杂度O(k2log⁡)O\\left(k^{2} \\log \\right)O(k2log)。\n D：\n改牛魔。\n哦，弱化版 链接。\n","categories":["总结"],"tags":["考试总结"]},{"title":"2024.10.10 总结","url":"/2024/10/10/2024.10.10%20%E6%80%BB%E7%BB%93/","content":" A：\n赛时发了什么疯非要来冲这题。\n不妨计各种颜色的宝石为 0/1。\n考虑记前缀和的最大值为 SmaxS_{max}Smax​，最小值为 SminS_{min}Smin​，于是总的限制为 ∣Smax−Smin∣≤k|S_{max}-S_{min}|\\leq k∣Smax​−Smin​∣≤k。\n考虑反向维护这个限制，即枚举一个 iii，然后钦定 i≤Smin≤Smax≤i+ki\\leq S_{min}\\leq S_{max}\\leq i+ki≤Smin​≤Smax​≤i+k，计算对应的序列个数。然后考虑一个实际差值为 Δ=∣Smax−Smin∣\\Delta=|S_{max}-S_{min}|Δ=∣Smax​−Smin​∣ 的序列，会被统计 k−Δ+1k-\\Delta+1k−Δ+1 次。记 calc(k)calc(k)calc(k) 为上述过程计算出的序列个数，于是有最终答案为 calc(k)−calc(k−1)calc(k)-calc(k-1)calc(k)−calc(k−1)。\n考虑 calc(k)calc(k)calc(k) 如何计算。考虑把一个 000 看做是在平面直角坐标系上让 xxx 坐标 +1+1+1，一个 111 为让 yyy 坐标 +1+1+1，于是问题转化为，从 (0,0)(0,0)(0,0) 出发，任意时刻在 y=x+iy=x+iy=x+i 和 y=x+i+ky=x+i+ky=x+i+k 之间，每次可以向右或向上走一步，问走到 nnn 的方案数。\n我们考虑条件为不能经过 y=x+i−1y=x+i-1y=x+i−1 和 y=x+i+k+1y=x+i+k+1y=x+i+k+1。我们记一次经过第一条直线的事件为 AAA，第二条直线为 BBB，我们考虑对形如 AABABBBA⋯AABABBBA\\cdotsAABABBBA⋯ 的前缀做容斥。\n我们把所有 AAA 合并在一起，所有 BBB 合并在一起，变成 ABABA⋯ABABA\\cdotsABABA⋯，然后一次经过 AAA 可以用经典卡特兰容斥理解为沿着 y=x+i−1y=x+i-1y=x+i−1 翻折。\n同理 ABABAB 即为先沿着 y=x+i−1y=x+i-1y=x+i−1 翻折，再沿着 y=x+i+k+1y=x+i+k+1y=x+i+k+1 翻折，我们减去翻折了奇数次的结果，加上翻折了偶数次的结果，即可得到最后答案。\n B：\n签到题目。\n考虑到当前点最多从前一百个点转移（di≤100d_i\\leq100di​≤100），将式子放进矩阵里加速就行。\n复杂度 O(d3 logk)\\mathcal O(d^3 \\ log k)O(d3 logk)。\n C：\n没有这题。\n D：\n开场觉得是个简单扫描线，写完 A 之后发现假了，不过绑包了居然没爆蛋（？\n题解说这才是签子，没看出来。\n不过正解还是扫描线。\n考虑对每种活动区间 [l,r][l,r][l,r] 增加两维 l′,r′l&#x27;,r&#x27;l′,r′ 分别表示移除左边界挡板和右边界挡板之后的活动范围为 (l′,r)(l&#x27;,r)(l′,r) 与 (l,r′)(l,r&#x27;)(l,r′)。那么两个区间 (l1,r1,l1′,r1′)(l_1,r_1,l_1&#x27;,r_1&#x27;)(l1​,r1​,l1′​,r1′​),(l2,r2,l2′,r2′)(l_2,r_2,l_2&#x27;,r_2&#x27;)(l2​,r2​,l2′​,r2′​) 能够同时坐人当且仅当 l1≥r2′l_1\\ge r_2&#x27;l1​≥r2′​ 且 l2′≥r1l_2&#x27;\\ge r_1l2′​≥r1​。\n由于不同的区间最多只有 4n4n4n 个，于是可以直接扫描线+set 维护找到。将所有区间按 r′r&#x27;r′ 排序，记录 fi/gif_i/g_ifi​/gi​ 表示考虑了前 iii 个区间，此时最多能坐多少人，并且在坐最多人的基础上最小的 rrr，那么对于某个区间 (l,r,l′,r′)(l,r,l&#x27;,r&#x27;)(l,r,l′,r′) 有转移：\n(fr′,gr′)←(fl+1,r) if (gl≤l′)(fi,gi)←(fi−1,gi−1)(f_{r&#x27;},g_{r&#x27;})\\gets(f_{l}+1,r)\\ \\text{if}\\ (g_l\\le l&#x27;)\\\\\n(f_i,g_i)\\gets (f_{i-1},g_{i-1})\n(fr′​,gr′​)←(fl​+1,r) if (gl​≤l′)(fi​,gi​)←(fi−1​,gi−1​)\n时间复杂度 O(nlog⁡n)\\mathcal O(n\\log n)O(nlogn)。\n\n然后就去体活了（喜，但是打球的时候很饿所以恼了。\n","categories":["总结"],"tags":["考试总结"]},{"title":"2024.10.11总结","url":"/2024/10/11/2024.10.11%E6%80%BB%E7%BB%93/","content":"最简单但挂分最惨的一集。\n唐死我了唐死我了唐死我了唐死我了唐死我了唐死我了唐死我了唐死我了唐死我了唐死我了唐死我了唐死我了唐死我了唐死我了唐死我了唐死我了唐死我了唐死我了唐死我了唐死我了唐死我了唐死我了唐死我了唐死我了唐死我了唐死我了唐死我了唐死我了唐死我了唐死我了唐死我了唐死我了唐死我了唐死我了唐死我了唐死我唐\n A：\n首先特判  n=1n=1n=1，考虑 n&gt;1n&gt;1n&gt;1 的情况：\n容易发现在树为链的时候 ansansans 最大，为  ⌊n2⌋+1\\left\\lfloor\\frac{n}{2}\\right\\rfloor+1⌊2n​⌋+1；在树为菊花的时候 ansansans 最小，为 222，继续往下找规律，发现将一个链尾指向链首，形成链套菊花，每次操作可以使答案减少 1。\n\n然后模拟即可。\n B：\n对于每个点，维护 valival_ivali​ 为当前点能跳到的最靠左的端点。\n对于 ∀i∈[1,n],ci=cn\\forall i\\in[1,n],c_i=c_n∀i∈[1,n],ci​=cn​，每次二分 + 哈希找到 LminL_{min}Lmin​，vali=min⁡(Lmin,valj,j∈[L−1,i])val_i=\\min(L_{min},val_j,j\\in[L-1,i])vali​=min(Lmin​,valj​,j∈[L−1,i])，其余的 valvalval 赋为 n+1n+1n+1 即可。\n树状数组维护即可，时间复杂度为 O(nlog⁡n)\\mathcal O(n\\log n)O(nlogn)。\n C：\n先考虑第二条限制，容易发现 BBB 中的数不能重复，接着打表发现 111 只能放在第一位，222 和 444 只能出现一个，333 只能放在最后，其余的数需倒序放置。\n差不多是这样：1,n,n−1...{4,2},31,n,n-1...\\{4,2\\},31,n,n−1...{4,2},3。\n现在带入第一条限制，容易发现最终取出的序列形态只有两种：\n\n{1,x,y,z}(x&gt;y&gt;z&gt;1)\\{1,x,y,z\\}(x&gt;y&gt;z&gt;1){1,x,y,z}(x&gt;y&gt;z&gt;1)\n{1,x,y,2,3}(x&gt;y≠4)\\{1,x,y,2,3\\}(x&gt;y\\neq4){1,x,y,2,3}(x&gt;y=4)\n\n设 fi,jf_{i,j}fi,j​ 为将 AjA_jAj​ 放在 BiB_iBi​ 的方案数，不难发现转移区间为 fi−1f_{i-1}fi−1​ 的一段后缀，开若干个树状数组优化转移即可。\n时间复杂度为 O(nlog⁡n)\\mathcal O(n\\log n)O(nlogn)。\n D：\n不会，没讲，广二老哥一个没改我改集贸。\n扔个题解：\n我们先忽略把圣遗物分成两份这个限制，思考该弱化版下二人的策略。\n可以感知到，在最终局面中，对于每一个圣遗物，二人都会尽量做到平均分配。\n这说明对于 si≢−1( mod 2ai)s_{i} \\not \\equiv-1\\left(\\bmod 2 a_{i}\\right)si​≡−1(mod2ai​) 的圣遗物 iii ，二人的收益都是 ci⌊si2ai⌋c_{i}\\left\\lfloor\\frac{s_{i}}{2 a_{i}}\\right\\rfloorci​⌊2ai​si​​⌋ 。而对于 si≡−1( mod 2ai)s_{i} \\equiv-1\\left(\\bmod 2a_{i}\\right)si​≡−1(mod2ai​) 的圣遗物 iii ，我们按 ccc 从大到小将其排序成 p1,p2,…,pmp_{1}, p_{2}, \\ldots, p_{m}p1​,p2​,…,pm​ ，则先手的额外收益为 ∑2i+1≤mcp2i+1\\sum_{2 i+1 \\leq m} c_{p_{2 i+1}}∑2i+1≤m​cp2i+1​​ ，后手的额外收益为 ∑2i≤mcp2i\\sum_{2 i \\leq m} c_{p_{2 i}}∑2i≤m​cp2i​​ 。\n回到原问题，我们据此 dp ，将所有圣遗物按 cic_{i}ci​ 从大到小排序，用 dpi,j,c1,c2dp_{i, j, c_{1}, c_{2}}dpi,j,c1​,c2​​ 表示考虑完前 iii 种圣遗物，第一份圣遗物个数为 jjj ，两份中 si≡−1( mod 2ai)s_{i} \\equiv-1\\left(\\bmod 2 a_{i}\\right)si​≡−1(mod2ai​) 的圣遗物 iii 的个数的奇偶性分别为 c1,c2c_{1}, c_{2}c1​,c2​ 小 w 的最大收益。转移时同时考虑一般贡献和额外贡献即可。\n时间复杂度 O((∑si)2)\\mathcal O\\left(\\left(\\sum s_{i}\\right)^{2}\\right)O((∑si​)2) ，可以通过第二个 Subtask。\n注意到，令其中一份中圣遗物 iii 的数量为 xix_{i}xi​ ，对于 xi mod 2aix_{i} \\bmod 2 a_{i}xi​mod2ai​ 值相同的 xix_{i}xi​ ，最终两份中圣遗物 iii 的贡献和是相同的，这启示我们只枚举 xi∈[0,2ai)x_{i} \\in\\left[0,2 a_{i}\\right)xi​∈[0,2ai​) ，但注意到我们原来的 dp 是在做背包的同时计算贡献，如果这样处理后背包便无法进行，于是我们考虑将背包分成  mod 2ai\\bmod 2 a_{i}mod2ai​ 的余数和 2ai2 a_{i}2ai​ 的倍数两部分做。\n特判掉 si&lt;2ais_{i}&lt;2 a_{i}si​&lt;2ai​ 的圣遗物，这些圣遗物我们用之前的 dp 暴力做，对于剩下部分，我们将余数做背包的同时算贡献，这部分复杂度为 O((∑ai)2)\\mathcal O\\left(\\left(\\sum a_{i}\\right)^{2}\\right)O((∑ai​)2) 。\n对于倍数部分的背包，我们需要知道倍数枚举的上界，但这和余数的实际值有关，看似无法继续。但观察到，可能的上界只有两种：令圣遗物 iii 分给第一份的个数的余数部分为 rir_{i}ri​ ，则当 ri≤si mod 2air_{i} \\leq s_{i} \\bmod 2 a_{i}ri​≤si​mod2ai​ 时，上界为 ⌊si2ai⌋\\left\\lfloor\\frac{s_{i}}{2 a_{i}}\\right\\rfloor⌊2ai​si​​⌋ ，否则为 ⌊si2ai⌋−1\\left\\lfloor\\frac{s_{i}}{2 a_{i}}\\right\\rfloor-1⌊2ai​si​​⌋−1 。\n我们不妨统一令上界为 ⌊si2ai⌋−1\\left\\lfloor\\frac{s_{i}}{2 a_{i}}\\right\\rfloor-1⌊2ai​si​​⌋−1 ，同时对于余数部分的 dp ，如果 ri≤si mod 2air_{i} \\leq s_{i} \\bmod 2 a_{i}ri​≤si​mod2ai​ ，我们多进行一个大小为 ri+2air_{i}+2 a_{i}ri​+2ai​ 背包转移即可。\n于是我们只用关心倍数部分的背包，即：给定 nnn 种物品，第 iii 种物品有 Li=⌊si2ai⌋−1L_{i}=\\left\\lfloor\\frac{s_{i}}{2 a_{i}}\\right\\rfloor-1Li​=⌊2ai​si​​⌋−1 个，每一个的体积为 Vi=2aiV_{i}=2 a_{i}Vi​=2ai​ ，问能不能凑出某个固定大小的背包。暴力做还是是 O((∑si)2)\\mathcal O\\left(\\left(\\sum s_{i}\\right)^{2}\\right)O((∑si​)2) 的，但这显然可以 bitset 优化，可以通过第三个 Subtask。\n做可行性 dp 显然是浪费的，我们更改定义为 gi,jg_{i, j}gi,j​ 表示前 iii 种物品想凑出大小为 jjj 的背包，第 iii 个物品至少要选多少个，不合法则 gi,j=−1g_{i, j}=-1gi,j​=−1 。\n对于该 dp ，显然可以通过分讨 O(1)\\mathcal O(1)O(1) 转移，时间复杂度 O(n∑si)\\mathcal O\\left(n \\sum s_{i}\\right)O(n∑si​) ，可以通过第四个 Subtask。\n考虑继续优化。我们发现，其实很多物品都是等价的。具体地，由于 2ai2 a_{i}2ai​ 只有最多 ∑ai\\sqrt{\\sum} a_{i}∑​ai​ 种，故我们把体积相同的物品合并，再做刚刚的 dp ，时间复杂度 O(∑ai∑si)\\mathcal O\\left(\\sqrt{\\sum} a_{i} \\sum s_{i}\\right)O(∑​ai​∑si​) ，可以通过本题。\n","categories":["总结"],"tags":["考试总结"]},{"title":"2024.10.9 总结","url":"/2024/10/09/2024.10.9%20%E6%80%BB%E7%BB%93/","content":"决定以后分开写，显的博客多。\n A：\n首先考虑对给定树计算权值，假设我们已经知道了一个权值最小的划分，那么可以通过调整得到新的划分使得权值不变，目的是简化虚树的形态。\n考虑该划分中任意一个集合形成的虚树，有两种情况：如果根节点 rrr 存在于任何一个最大独立集中，即 fr,1&gt;fr,0f_{r,1}&gt;f_{r,0}fr,1​&gt;fr,0​，则不存在 rrr 的儿子 vvv 使得 fv,0&lt;fv,1f_{v,0} &lt; f_{v,1}fv,0​&lt;fv,1​。\n此时，将该虚树中的点按照 rrr 的不同子树分成多个集合，并将 rrr 任意放入一个集合（如果 rrr 不是虚点），则权值一定不会增大；\n反之，若 fr,1≤fr,0f_{r,1}\\leq f_{r,0}fr,1​≤fr,0​，则存在 vvv 使得 fv,0&lt;fv,1f_{v,0}&lt; f_{v,1}fv,0​&lt;fv,1​。此时，将虚树中的点按照 rrr 的子树分开，将 rrr 归入子树 vvv，权值也不会增大。\n根据以上思路，我们可以归纳地证明，权值最小的划分一定只由两种结构组成：一个孤点，或者一个有祖先后代关系的点对。\n我们已经证明了可以将 rrr 的所有子树分开，而不会增大权值。由归纳假设，rrr 的所有子树都可以调整为只由孤点和点对组成的划分，如果其中存在孤点，我们将其与 rrr 匹配为点对，否则将 rrr 作为孤点，容易得到，这样依然不会增大权值。\n因为孤点和点对的权值都是 111，所以权值最小的划分就是要最大化选出的点对数。\n考虑 dp，记 gug_ugu​ 表示 uuu 的子树内最优的划分会剩下多少个孤点。如果 ∑vgv&gt;0\\sum_v g_v&gt;0∑v​gv​&gt;0，则让 uuu 与一个孤点匹配，即 gu=∑vgv−1g_u=\\sum_v g_v - 1gu​=∑v​gv​−1，否则 gu=1g_u=1gu​=1。最终答案为 n+g02\\frac{n+g_0}{2}2n+g0​​。\n对于加点，可以考虑类似 DDP 的做法，树剖后，可以求出轻子树的 ∑gv\\sum g_v∑gv​，我们需要维护函数 h(x)h(x)h(x) 表示当重儿子 gs=xg_s=xgs​=x 时 gug_ugu​ 的值，h(x)h(x)h(x) 是一个分段函数，存在分界点 ppp，满足 x≤px\\leq px≤p 时 h(x)=a(x∧1)+bh(x)=a\\left(x\\wedge1\\right)+bh(x)=a(x∧1)+b（(x∧1)\\left(x\\wedge1\\right)(x∧1) 表示 xxx 的奇偶性），x&gt;px&gt;px&gt;p 时 h(x)=x+ch(x)=x+ch(x)=x+c。\n因此，h(x)h(x)h(x) 是可合并的，支持快速复合，可以用线段树维护，套用 DDP 的做法。\n B：\n设 kkk 为区间长度，考虑置换环，ppp 进行一次置换相当于每个位置变为置换环上的下一个位置，终止条件为 [l,r][l,r][l,r] 对应 ppp 的值域也为 [l,r][l,r][l,r]。\n考虑到满足条件的排列每次置换完后区间 [l,r][l,r][l,r] 仍为一个值域连续段，内部可以自由排列，其贡献为：\n∑i=1⌊nk⌋(k!)i⋅(i−1)!⋅(n−ik)!⋅Fi,l−1,n−r,k\\sum_{i=1}^{\\left\\lfloor\\frac{n}{k}\\right\\rfloor}(k!)^{i} \\cdot(i-1)!\\cdot(n-i k)!\\cdot F_{i, l-1, n-r, k} \ni=1∑⌊kn​⌋​(k!)i⋅(i−1)!⋅(n−ik)!⋅Fi,l−1,n−r,k​\n其中：\nFi,x,y,k=∑j=0i−1(x−j(k−1)j)(y−(i−j−1)(k−1)i−j−1)F_{i, x, y, k}=\\sum_{j=0}^{i-1}\\binom{x-j(k-1)}{j}\\binom{y-(i-j-1)(k-1)}{i-j-1} \nFi,x,y,k​=j=0∑i−1​(jx−j(k−1)​)(i−j−1y−(i−j−1)(k−1)​)\n对于所选中区间相交的情况有结论：“如果将所有相交的区间合并成一个连续段，则每一个连续段有且仅有两个区间，且所有连续段长度相同。在通过置换环向后跳的过程中，会首先依次经过每个连续段中的一个区间，再按相同的顺序经过每个连续段中的另一个区间，最后回到初始区间。”\n若一个连续段是由 [l1,r1][l_1,r_1][l1​,r1​] 与区间 [l2,r2][l_2,r_2][l2​,r2​] 构成，不妨设 l1&lt;l2l_1&lt;l_2l1​&lt;l2​ ，若左区间最小值小于右区间最小值，则称该连续段是上升的，否则为下降的。\n假设一共形成了  mmm 个连续段，这些连续段的指向关系会构成一个圆排列，其中下降段的个数一定为奇数。\n不妨设 [l,r][l,r][l,r] 连续段为上升的，则该部分贡献为：\n∑d=1k−1∑i=1⌊nk⌋2i−1⋅((k−d)!2⋅d!)i⋅(i−1)!⋅(n−i(2k−d))!⋅Fi,l−1,n−r−k+d,2k−d\\sum_{d=1}^{k-1} \\sum_{i=1}^{\\left\\lfloor\\frac{n}{k}\\right\\rfloor} 2^{i-1} \\cdot\\left((k-d)!^{2} \\cdot d!\\right)^{i} \\cdot(i-1)!\\cdot(n-i(2 k-d))!\\cdot F_{i, l-1, n-r-k+d, 2 k-d} \nd=1∑k−1​i=1∑⌊kn​⌋​2i−1⋅((k−d)!2⋅d!)i⋅(i−1)!⋅(n−i(2k−d))!⋅Fi,l−1,n−r−k+d,2k−d​\n后边的 FFF 可以用 NTT 计算，总时间复杂度为 O(nlog⁡n)\\mathcal{O}(n\\log n)O(nlogn)。\n C：\n爱谁改谁改\n\n\n下午把键盘拆开擦了一遍，国庆放假时机房换灯掉下来的墙皮全掉键盘缝里了，擦完舒服多了。\n怎么会有人能做到用了两个月的新键盘 键帽比我用了大半年的还油的。\n最近有点神金事整的我挺烦的。\n","categories":["总结"],"tags":["考试总结"]},{"title":"2024.10.12总结","url":"/2024/10/12/2024.10.12%E6%80%BB%E7%BB%93/","content":" A：\n对于上述整除式的一组解 (c,s)(c, s)(c,s) ，在 c≤a≤Ac \\leq a \\leq Ac≤a≤A 且 s≤b≤Bs \\leq b \\leq Bs≤b≤B 时，会被统计入答案，因此它对答案的贡献为 (A−c−1)(B−s−1)(A-c-1)(B-s-1)(A−c−1)(B−s−1) 。\n在 s&gt;xs&gt;xs&gt;x 时，注意到 ss+x&gt;12\\frac{s}{s+x}&gt;\\frac{1}{2}s+xs​&gt;21​ ， cc+x&lt;1\\frac{c}{c+x}&lt;1c+xc​&lt;1，因此 k=cc+xss+x&lt;112=2k=\\frac{\\frac{c}{c+x}}{\\frac{s}{s+x}}&lt;\\frac{1}{\\frac{1}{2}}=2k=s+xs​c+xc​​&lt;21​1​=2 ，所以 k=1k=1k=1 。此时可得 c=sc=sc=s 。\n记 p=min⁡(n,m)p=\\min (n, m)p=min(n,m)：\nans=c∑i=x+1p(n+1−i)(m+1−i)=∑i=x+1p(n+1)(m+1)−(n+m−2)∑i=x+1pi+∑i=x+1pi2=(n+1)(m+1)(p−x)−12(n+m+2)(p−x)(p+x+1)+16p(p+1)(2p+1)−16x(x+1)(2x+1)\\begin{aligned}\nans&amp;={c} \\sum_{i=x+1}^{p}(n+1-i)(m+1-i) \\\\ \n&amp;=\\sum_{i=x+1}^{p}(n+1)(m+1)-(n+m-2) \\sum_{i=x+1}^{p} i+\\sum_{i=x+1}^{p} i^{2} \\\\ \n&amp;=(n+1)(m+1)(p-x)-\\frac{1}{2}(n+m+2)(p-x)(p+x+1)+\\frac{1}{6} p(p+1)(2 p+1)-\\frac{1}{6} x(x+1)(2 x+1)\\\\\n\\end{aligned}\nans​=ci=x+1∑p​(n+1−i)(m+1−i)=i=x+1∑p​(n+1)(m+1)−(n+m−2)i=x+1∑p​i+i=x+1∑p​i2=(n+1)(m+1)(p−x)−21​(n+m+2)(p−x)(p+x+1)+61​p(p+1)(2p+1)−61​x(x+1)(2x+1)​\n在 s≤xs \\leq xs≤x 时，注意到 k=cc+xss+x&lt;1ss+x=s+xs=1+xsk=\\frac{\\frac{c}{c+x}}{\\frac{s}{s+x}}&lt;\\frac{1}{\\frac{s}{s+x}}=\\frac{s+x}{s}=1+\\frac{x}{s}k=s+xs​c+xc​​&lt;s+xs​1​=ss+x​=1+sx​。\n暴力枚举 s,ks, ks,k，复杂度为 ∑i=1xxi\\sum_{i=1}^{x} \\frac{x}{i}∑i=1x​ix​ 为调和级数，此时暴力枚举每组解，累加贡献即可，时间复杂度为 xlog⁡x\\mathcal x\\log xxlogx。\n B：\n我们发现两个点 u,vu,vu,v 在同一个点集的充分条件是：对于所有不是 u,vu,vu,v 的点 xxx，要么 u,vu,vu,v 与 xxx 之间均有直接连边，要么 u,vu,vu,v 与 xxx 之间均无直接连边。\n容易想到哈希，每个点维护该点与别的点是否有直接连边。\n而我们仅需讨论一下 u,vu,vu,v 是否存在边即可，我们如果直接维护这两个点是否有边也是可以做的，或者我们可以考虑同时维护 hashu=hashvhash_u=hash_vhashu​=hashv​ 和 hashuxor⁡valv=hashvxor⁡valuhash_u \\operatorname{xor} val_v=hash_v \\operatorname{xor} val_uhashu​xorvalv​=hashv​xorvalu​，如果这两个点不在同一连通块，则这两个等式均不成立，否则一定只会成立其中一个。\n时间复杂度 O(n)\\mathcal O(n)O(n)。\n C：\n牛魔酬宾\n D：\n牛魔酬宾\n原题\n","categories":["总结"],"tags":["考试总结"]},{"title":"8.19~9.30 考试总结","url":"/2024/08/19/8.19~9.30%20%E8%80%83%E8%AF%95%E6%80%BB%E7%BB%93/","content":" 2024.8.19：\n A：\n模拟题。\n B：\n直接搜索。\n C：\n原题可转化成寻找二进制下后缀连续1的个数的所有可能，将所有数反转，存进线性基再枚举即可。\n D：\nn小的情况直接上最小乘积生成树，大的情况用凸包合并。\n 2024.8.20：\n A：\n推公式，发现是求动态逆序对，可用树套树/cdp等方法解决。\n B：\n考虑分治，再用线段树维护即可。\n C：\n可以转化成二分图最大权匹配，但点/边数过多，贪心，只选择前2nk2nk2nk大的边和对应点，可以大大降低总点数，由于是稀疏图且点数较少，用mcmf可以解决。\n D：\n析合树板子，也可以离线下来用线段树和单调栈维护。\n 2024.8.21：\n A ：\n明显是个背包，不过有点麻烦，需要支持撤回，用可撤销背包维护即可，枚举哪一个掉进魔法洞直接把 for 循环倒过来做\n一遍就可以了\n B ：\n考虑对每个sis_{i}si​，先将sis_{i}si​中的MMM个字符串都只保留其中最短那个的长度，再将si,js_{i,j}si,j​一位一位地依次串起来，得到字符串rir_{i}ri​(例如：si={abcde,fghi,xxxxxx⁡}s_{i}=\\{  abcde, fghi,  \\operatorname{xxxxxx}\\}si​={abcde,fghi,xxxxxx}，先将它们长度都变成 4 ，{abcd,fghi,xxxx}\\{\\mathrm{abcd} , \\mathrm{fghi}, \\mathrm{xxxx}\\}{abcd,fghi,xxxx}，然后串起来，ri=afxbgxchxdixr_{i}=\\mathrm{afxbgxchxdix}ri​=afxbgxchxdix）。\n然后将rir_{i}ri​放进 trie 中，和M=1M=1M=1类似的，对树上每个点计算出以它为 LCA 的点对个数，它对答案的贡献是⌊ depth M⌋\\left\\lfloor\\frac{\\text { depth }}{M}\\right\\rfloor⌊M depth ​⌋(depth 为该点深度) 。\n C ：\n给每行赋予一个随机值wiw_{i}wi​，用于哈希，预处理si,js_{i, j}si,j​表示bbb矩阵第iii列，等于jjj的行的随机值的和，然后枚举每一行，检查是否合法就行了。\n D ：\n考虑吉司机线段树，维护aaa最大、次大值，对应的b,cb , cb,c的最大、次大值，将询问离线下来即可。\n 2024.8.22：\n A ：\n很明显倒着模拟与正着模拟等价，所以从后往前枚举即可。\n B ：\n考虑有效的值数量很少，用map维护，直接搜索即可。\n C ：\n观察性质，发现在最优情况下，一个点与其对应的前缀最大值和后缀最小值之间至少存在一条边。\n考虑树的性质，对n−1n-1n−1个点，每个点连出一条边即可得到最小值。\n直接这么贪心连边显然不行，因为会出现环（example：0 1 -1 1，这里1和-1会相互连边）。\n所以先排序，用若干个最小值将原数列分为若干个连续段，使得段内每个数对应的后缀最小值相同。\n从前往后操作每个段：\n\n\n对于非段尾的数，要么与前缀最大值连边，要么与段尾连边，取minminmin即可。\n\n\n对于段尾的数，自身为后缀最小值，所以只能与最大值连边，但考虑若段内产生前缀最大值，必定与段尾连边，所以只能选择之前段中的最大值。\n\n\n D ：\n思路就是询问时Σ2\\Sigma^{2}Σ2枚举字符，然后实现O(1)O(1)O(1)计算这两个字符在询问区间内的串长就可以过掉，考虑维护每个相同字符的管辖范围，用nex数组记录，每次直接跳就行。\n 2024.8.23：\n A ：\n考虑合法分割的性质，要么大小为偶且均合法，要么为奇且存在一个不合法，前者为子树大小相乘，后者为合法的点数相乘，用树形dp维护，再考虑换根转移，用前缀和维护，这样可以计算出每棵树子树的答案，最后枚举每条边断掉后的贡献即可。\n B ：\n可以观察到最小时间等于N 减去补图的最大匹配。可以证明本题的答案和补图的最大匹配是双射（具体的映射应该很好猜），那么我们对于一组最大匹配只需要一直找入度为0的点就可以排出一个操作顺序。\n 2024.8.24：\n A ：\n维护每个数可出现的区间，将区间长度乘起来即可。\n B ：\n建立SAM，将概率模型建立在自动机上，消元，用维护无向图的方法维护即可。\n C ：\n考虑搜索，朴素算法过不了，所以用bitset维护加边情况，可以降低很多复杂度，卡卡常就过了。\n 2024.8.26：\n A ：\n经典组合数求解，从一个障碍点向下一个障碍点转移，方案数可以用组合数处理，需要用lgv引理优化，复杂度较优。\n B ：\n可以分为非等边的等腰三角形、等边三角形，和普通三角形，前两个可以分别计算，最后一个用离散二位数点维护。\n C ：\n用ax+b表示每一条边，将代入矩阵树定理中，将a表示成矩阵A,b表示成矩阵B，首先将A消成单位矩阵，同时对B乘上a−1a^{-1}a−1，现在我们要求的就是xI+BxI+BxI+B的行列式，我们考虑将这个矩阵消成海森堡矩阵,在消元完之后我们就可以将矩阵的值表示成一个n次多项式，计算自然数幂和即可。\n 2024.8.27：\n A ：\n用dp求出和为sum，只由j以上的素数构成，且长度为i的方案数，搜索时加上方案数，若小于l则直接跳过该分枝，否则直接展开输出。\n B ：\n将序列上AC自动机，再自动机上进行期望dp转移即可。\n C ：\n维护序列哈希，O（1）O（1）O（1）维护修改，每次直接查询即可，最好使用umap防止卡常。\n D ：\n双指针维护前后缀+ST表，求个路径交即可，比较简单。\n 2024.8.28：\n A ：\n对一个下标的修改次数分类。设一个间值BBB，对修改次数&gt;B&gt;B&gt;B的下标使用O(n+q)\\mathcal{O}(n+q)O(n+q)的暴力。\n B ：\n实际上，根据算法中的ttt，整个算法可以描述成: 初始t=n−mt=n-mt=n−m，每次若t&lt;0t&lt;0t&lt;0则进行RRR(同时ttt加nnn)，若t&gt;0t&gt;0t&gt;0则进行UUU（同时ttt减mmm），若t=0t=0t=0则停止；\n如果交换nnn与mmm也有同样的描述（交换nnn与m，Rm ， Rm，R与U)U)U)。\n若n=1n=1n=1直接快速幕，若n&gt;mn&gt;mn&gt;m就交换nnn与mmm（也要交换RRR与UUU），若n&lt;mn&lt;mn&lt;m，则令p=m mod n,q=⌊m/n⌋p=m \\bmod n, q=\\lfloor m / n\\rfloorp=mmodn,q=⌊m/n⌋，那么也可以描述成：先进行Rq，t=n−m+qn=n−(m mod n)=n−pR^{q} ， t=n-m+q n=n-(m \\bmod n)=n-pRq，t=n−m+qn=n−(mmodn)=n−p，每次t&lt;0t&lt;0t&lt;0则进行RRR(同时ttt加nnn)，否则进行一次URqU R^{q}URq(同时ttt减(m−qn)=p(m-q n)=p(m−qn)=p)，则把(n,m,R,U)(n, m, R, U)(n,m,R,U)的情形化为(n,p,R,URq)\\left(n, p, R, U R^{q}\\right)(n,p,R,URq)的情形，即辗转相除。\n每次计算RqR^{q}Rq用快速幕可以做到O(log⁡q)\\mathcal{O}(\\log q)O(logq)，同时nmn mnm至少降到原来的1/q1 / q1/q。\n C ：\n可以暴力建最小割树取得70分暴力分，考虑正解，我们反复操作直至图上不存在一个凸包为止，这样我们就建出了最小割树。对于每一条边的贡献我们按照克鲁斯卡尔贪心地去计算即可，注意到我们删去一条边的过程，我们如果删去一条边，那么就意味着需要在找到端点的最短路的同时将最短路上的边加入外层边集合。由于原图是一个凸包，按照标号的规律，就可以简单地通过对编号排序实现边的极角排序。\n 2024.8.30：\n A ：\n考虑 DP，设dp[i][0/1]d p[i][0 / 1]dp[i][0/1]表示[1,i][1, i][1,i]正确划分的方案数，其中最后一段是否合法，当gcd⁡(D,10)=1\\operatorname{gcd}(D, 10)=1gcd(D,10)=1时，相当于是pre[j]≡pre[i+1]( mod D)p r e[j] \\equiv p r e[i+1](\\bmod D)pre[j]≡pre[i+1](modD)，直接开个桶就好。当gcd⁡(D,10)≠1\\operatorname{gcd}(D, 10) \\neq 1gcd(D,10)=1时，设D=2x5ymD=2^{x} 5^{y} mD=2x5ym，那么相当于要求%2x,%5y,%m\\% 2^{x}, \\% 5^{y}, \\% m%2x,%5y,%m同时为 0 。\n对于固定的iii，在j≤i−20j \\leq i-20j≤i−20以后s[j]s[j]s[j]的贡献%2x,%5y\\% 2^{x}, \\% 5^{y}%2x,%5y都是 0 了，只用考虑mmm的限制，此时同样可以对%m\\% m%m开桶。对于j&gt;i−20j&gt;i-20j&gt;i−20直接暴力即可。\n B ：\n考虑到幸运数字的数目很少,考虑直接爆搜+剪枝即可通过。\n C ：\n我们发现，从删掉(i,i+1)(i, i+1)(i,i+1)移动到删掉(i+1,i+2)(i+1, i+2)(i+1,i+2)产生的影响并不多，严格来说均摊变化量是O(P)\\mathcal{O}(P)O(P)的。开一个线段树，相当于每次做区间+1/−1+1 /-1+1/−1，查询全局&gt;0&gt;0&gt;0的位置权值之和。\n D ：\n我们发现可以O(1)\\mathcal{O}(1)O(1)计算出disd i sdis的上升和下降段分别是多少，在最终的结果数组里打一个差分标记即可。注意需要特判i=0,Ki=0, Ki=0,K等情况。\n 2024.9.2：\n A :\n先看整数部分，我们设fi,jf_{i, j}fi,j​表示考虑到xix_{i}xi​，所有情况下和的jjj次方的和 (期望除一个方案数就行)，则有：\nfi,j=∑p=liri−1∑t=0j(jt)fi−1,j−tpt=∑t=0j(jt)fi−1,j−t∑p=liri−1pt\\begin{aligned}\nf_{i, j} &amp; =\\sum_{p=l_{i}}^{r_{i}-1} \\sum_{t=0}^{j}\\binom{j}{t} f_{i-1, j-t} p^{t} \\\\\n&amp; =\\sum_{t=0}^{j}\\binom{j}{t} f_{i-1, j-t} \\sum_{p=l_{i}}^{r_{i}-1} p^{t}\n\\end{aligned}\nfi,j​​=p=li​∑ri​−1​t=0∑j​(tj​)fi−1,j−t​pt=t=0∑j​(tj​)fi−1,j−t​p=li​∑ri​−1​pt​\n我们发现后面是一个自然数ttt次方和的形式，可以插值轻松求出。这部分复杂度是Θ(nk3)\\Theta\\left(n k^{3}\\right)Θ(nk3)，预处理一下就变成了Θ(nk2)\\Theta\\left(n k^{2}\\right)Θ(nk2)。\n再考虑小数部分，这就是所有数取值范围都是[0,1)[0,1)[0,1)的那一档部分分。考虑最后⌊x1+x2+…+xn⌋\\left\\lfloor x_{1}+x_{2}+\\ldots+x_{n}\\right\\rfloor⌊x1​+x2​+…+xn​⌋的取值不会超过nnn，我们对 1 到n−1n-1n−1都求出取到它的概率。\n我们设sis_{i}si​为∑j=1ixj\\sum_{j=1}^{i} x_{j}∑j=1i​xj​的小数部分，容易发现，⌊x1+x2+…+xi⌋=⌊x1+x2+…+xi−1⌋+1\\left\\lfloor x_{1}+x_{2}+\\ldots+x_{i}\\right\\rfloor=\\left\\lfloor x_{1}+x_{2}+\\ldots+x_{i-1}\\right\\rfloor+1⌊x1​+x2​+…+xi​⌋=⌊x1​+x2​+…+xi−1​⌋+1当且仅当si&lt;si−1s_{i}&lt;s_{i-1}si​&lt;si−1​。\n我们不妨将sis_{i}si​替换成sis_{i}si​在整个数列中的排名，最后会的得到一个序列。\n显然所有n!n!n!种序列出现的概率都是相等的。考虑dp，设gi,jg_{i, j}gi,j​表示长度为iii的序列有jjj个位置满足si&lt;si−1s_{i}&lt;s_{i-1}si​&lt;si−1​的方案数。\n我们从小到大往序列里插数。有四种情况:\n1.插在开头，从gi−1,j−1g_{i-1, j-1}gi−1,j−1​转移过来。\n2.插在结尾，从gi−1,jg_{i-1, j}gi−1,j​转移过来。\n3.插在一个满足si&lt;si−1s_{i}&lt;s_{i-1}si​&lt;si−1​的位置中间，从j×gi−1,jj \\times g_{i-1, j}j×gi−1,j​转移过来。\n4.插在一个满足si&gt;si−1s_{i}&gt;s_{i-1}si​&gt;si−1​的位置中间，从(i−j−1)×gi−1,j−1(i-j-1) \\times g_{i-1, j-1}(i−j−1)×gi−1,j−1​转移过来。\n所以我们得到方程:gi,j=(j+1)×gi−1,j+(i−j)×gi−1,j−1g_{i, j}=(j+1) \\times g_{i-1, j}+(i-j) \\times g_{i-1, j-1}gi,j​=(j+1)×gi−1,j​+(i−j)×gi−1,j−1​，可以Θ(n2)\\Theta\\left(n^{2}\\right)Θ(n2)求出。\n B :\n现在我们想要得到一个概率生成函数，即设BiB_{i}Bi​表示随机了恰好iii次之后停止的概率，B(x)=B(x)=B(x)=∑i=0∞Bixi\\sum_{i=0}^{\\infty} B_{i} x^{i}∑i=0∞​Bi​xi，那么有\nB(x)=P(xm)Q(xm)B(x)=\\frac{P\\left(\\frac{x}{m}\\right)}{Q\\left(\\frac{x}{m}\\right)}\nB(x)=Q(mx​)P(mx​)​\n再考虑如何计算答案，答案的 EGF 为B(ex)B\\left(e^{x}\\right)B(ex)。\nBBB的分子和分母上的都是一个有限次的多项式。\n换言之，现在问题规约成，有一个NNN次多项式FFF，我们想要求F(ex)F\\left(e^{x}\\right)F(ex)对某个xMx^{M}xM取模之后的结果。\nF(ex) mod xM=∑k=0NFk⋅ekx=∑k=0NFk⋅∑i=0∞kixii!=∑i=0M−1xii!∑k=0NFk⋅ki\\begin{aligned}\n&amp; F\\left(e^{x}\\right) \\bmod x^{M} \\\\\n= &amp; \\sum_{k=0}^{N} F_{k} \\cdot e^{k x} \\\\\n= &amp; \\sum_{k=0}^{N} F_{k} \\cdot \\sum_{i=0}^{\\infty} \\frac{k^{i} x^{i}}{i!} \\\\\n= &amp; \\sum_{i=0}^{M-1} \\frac{x^{i}}{i!} \\sum_{k=0}^{N} F_{k} \\cdot k^{i}\n\\end{aligned}\n===​F(ex)modxMk=0∑N​Fk​⋅ekxk=0∑N​Fk​⋅i=0∑∞​i!kixi​i=0∑M−1​i!xi​k=0∑N​Fk​⋅ki​\n这个可以通过计算\n∑kFk1−kx\\sum_{k} \\frac{F_{k}}{1-k x}\nk∑​1−kxFk​​\n来完成。\n C ：\n拓展gcd写掉部分分，我们将其拓展一下，用向量作为exgcd的基底，和实数一样带入系数计算即可。\n 2024.9.3：\n A ：\n期望部分很好求，直接枚举每一个三元环算贡献即可。求最大值，考虑每个点每有两条出边便会使三元环个数减一，每条边会使两个端点中的一个出度加一，将每个点被选次数的贡献做个差分，上费用流即可。\n B ：\n发现一个瓶颈在求最小的lll，其实就是该前缀的最长后缀，而参与匹配的是SSS的所有字串，所以想到维护所有字串信息的后缀自动机，所以我们开nnn个后缀自动机，求出对应的最小lll就可以∣T∣2|T|^{2}∣T∣2转移了。\n C :\n首先f(n,0)=1f(n, 0)=1f(n,0)=1，之后\nf(n,k)=∑x1=0n(nx1)∑x2=0x1(x1x2)∑x3=0x2(x2x3)…∑xk=0xk−1(xk−1xk)f(n, k)=\\sum_{x_{1}=0}^{n}\\binom{n}{x_{1}} \\sum_{x_{2}=0}^{x_{1}}\\binom{x_{1}}{x_{2}} \\sum_{x_{3}=0}^{x_{2}}\\binom{x_{2}}{x_{3}} \\ldots \\sum_{x_{k}=0}^{x_{k-1}}\\binom{x_{k-1}}{x_{k}}\nf(n,k)=x1​=0∑n​(x1​n​)x2​=0∑x1​​(x2​x1​​)x3​=0∑x2​​(x3​x2​​)…xk​=0∑xk−1​​(xk​xk−1​​)\n运用二项式定理对每一 “层” 都运用二项式定理&quot;剥壳&quot;\nf(n,k)=∑x1=0n(nx1)⋯∑xk−1=0xk−2(xk−2xk−1)2xk−1f(n, k)=\\sum_{x_{1}=0}^{n}\\binom{n}{x_{1}} \\cdots \\sum_{x_{k-1}=0}^{x_{k-2}}\\binom{x_{k-2}}{x_{k-1}} 2^{x_{k-1}}\nf(n,k)=x1​=0∑n​(x1​n​)⋯xk−1​=0∑xk−2​​(xk−1​xk−2​​)2xk−1​\n具体地以后面∑xk−1=0xk−2(xk−2xk−1)2xk−1\\sum_{x_{k-1}=0}^{x_{k-2}}\\binom{x_{k-2}}{x_{k-1}} 2^{x_{k-1}}∑xk−1​=0xk−2​​(xk−1​xk−2​​)2xk−1​为例运用二项式定理&quot;剥壳&quot;，可以知道:\n∑xk−1=0xk−2(xk−2xk−1)2xk−1=3xk−2\\sum_{x_{k-1}=0}^{x_{k-2}}\\binom{x_{k-2}}{x_{k-1}} 2^{x_{k-1}}=3^{x_{k-2}}\nxk−1​=0∑xk−2​​(xk−1​xk−2​​)2xk−1​=3xk−2​\n所以:f(n,k)=(k+1)nf(n, k)=(k+1)^{n}f(n,k)=(k+1)n，那么:\nf(f(n,i),i)=(i+1)(i+1)nf(f(n, i), i)=(i+1)^{(i+1)^{n}}\nf(f(n,i),i)=(i+1)(i+1)n\n快速幕计算即可。注意运用欧拉定理计算快速幕时应该模 mod −1\\bmod -1mod−1。\n 2024.9.4：\n A :\n我们考虑二元生成函数：\nG(x,y)=∑i≥0∑j≥0 one (i,j)xiyjG(x, y)=\\sum_{i \\geq 0} \\sum_{j \\geq 0} \\text { one }(i, j) x^{i} y^{j}\nG(x,y)=i≥0∑​j≥0∑​ one (i,j)xiyj\n那么可以得到：\n ways (i,j)=[xiyj]∑k≥0G(x,y)k=[xiyj]11−G(x,y)\\text { ways }(i, j)=\\left[x^{i} y^{j}\\right] \\sum_{k \\geq 0} G(x, y)^{k}=\\left[x^{i} y^{j}\\right] \\frac{1}{1-G(x, y)}\n ways (i,j)=[xiyj]k≥0∑​G(x,y)k=[xiyj]1−G(x,y)1​\n那么二元多项式的求逆可以通过 NTT 来解决。复杂度为O(10002log⁡1000)O\\left(1000^{2} \\log 1000\\right)O(10002log1000)。\n B ：\n考虑贪心求区间极大段，用区间和减去即可。\n C ：\n考虑 dsu on tree，那么根据dsu on tree的过程，我们要处理轻儿子间的合并以及重链的信息继承，发现前者很容易，只需要分治 FFT\n或者启发式合并就可以完成。但后者没那么容易处理，原因是最后加x 的过程。重新观察转移，发现可以写成矩阵形式，即\n(Fx000Fx1001)\\left(\\begin{array}{ccc}\nF_{x} &amp; 0 &amp; 0 \\\\\n0 &amp; F_{x} &amp; 1 \\\\\n0 &amp; 0 &amp; 1\n\\end{array}\\right)\n⎝⎛​Fx​00​0Fx​0​011​⎠⎞​\n然后答案矩阵是\n(FG1)\\left(\\begin{array}{c}F \\\\ G \\\\ 1\\end{array}\\right)\n⎝⎛​FG1​⎠⎞​\n 2024.9.5：\n A ：\n考虑把操作倒过来，就变成每次加一个点。用并查集维护连通块以及其权值和即可。\n B ：\n考虑在kkk次fff操作后，原数组中位置(i,j)(i, j)(i,j)对答案的贡献，是(ki)×(kj)\\binom{k}{i} \\times\\binom{ k}{j}(ik​)×(jk​)次。由于是异或操作，所以只有在贡献次数为奇数时才有实际的贡献。\n那么真正需要考虑的kkk就是max⁡(n,m)\\max (n, m)max(n,m)在二进制下最高位以内的数位。也就是只需要预处理出0≤k&lt;2230 \\leq k&lt;2^{23}0≤k&lt;223的答案。使用高维前缀和优化即可。\n C：\n分成 “存在交为空的集合” 与 “不存在交为空的集合” 来讨论。\n如果存在交为空的集合，显然只能有一个 (不然可以合并起来)。然后其余的集合大小一定为 1 ，否则可以只保留里面长度最长的线段。因此这种情况只要按长度排序，贪心选择最长的那些。\n如果不存在交为空的集合，对于线段iii和jjj，如果iii完全包含了jjj，那么iii只有两种选择：跟jjj放在同一个集合，或者自己独占一个集合。其他选择可以用调整证明不会更优。\n因此对于完全包含了某个其他线段的线段，我们要么忽略它，要么让它独占一个集合。对于剩下的线段，排好序后显然左右端点都是单调的，调整可以证明每个划分的集合都是占据了一个连续段。\n考虑f(i,j)f(i, j)f(i,j)表示用iii个集合划分前jjj条线段的最大权值，转移形如:\nf(i,j)=max⁡k&lt;j(f(i−1,k)+rk+1−lj)f(i, j)=\\max _{k&lt;j}\\left(f(i-1, k)+r_{k+1}-l_{j}\\right)\nf(i,j)=k&lt;jmax​(f(i−1,k)+rk+1​−lj​)\n可以使用前缀和优化转移。\n最后与完全包含了某个其他线段的线段的贡献合并一下就可以得到答案了。\n D:\n考虑点分治，每次求出在当前处理的这个连通块中，包含分治中心且符合条件的方案数。求出以分治中心为根的 dfs 序，考虑f(i,j)f(i, j)f(i,j)表示考虑了 dfs 序中的前iii项，目前点集内乘积为jjj的方案数。\n注意到状态里记录乘积恰好为jjj很浪费，可以记录最大还能乘到多少，即f(i,⌊mj⌋)f\\left(i,\\left\\lfloor\\frac{m}{j}\\right\\rfloor\\right)f(i,⌊jm​⌋)表示考虑了 dfs 序中的前iii项，目前点集内乘积为jjj的方案数，这样第二维就只有O(m)O(\\sqrt{m})O(m​)种取值。\n转移的话，每次在递归的时候将这个点的方案传给儿子，再在回溯的时候将儿子的贡献加回父亲上即可。\n 2024.9.6：\n A ：\n打一下表发现操作次数循环节为23到46，于是用分块维护每一段操作前46次操作后的答案。\n B ：\n考虑将石子分为大小为/不为一的两组，然后记忆化搜索即可，注意取石子时的合并细节。\n C:\n能否构造出最大匹配恰为给定值xxx的充要条件是: 去掉 0 度点后xxx不大于二分图其中一边的点数，且存在一个大小为xxx的点集SSS(其中的点可以分布在两边) 满足SSS中的点的度数之和恰为边数mmm。\nO(n6)\\mathrm{O}\\left(n^{6}\\right)O(n6)的DP大概就是记f[i][j][k][l][m]f[i][j][k][l][m]f[i][j][k][l][m]表示做了前iii个点，其点度之和为j，Sj ， Sj，S中有kkk个非 0 度点，SSS中点度和为l,Sl, Sl,S外有lll个非 0 度点就可以直接DP了。\n 2024.9.9：\n A ：\n用优先队列维护节点，以当前节点到子树中最深节点的距离为关键字，每次选mmm个即可。\n B ：\n博弈论。\n C ：\n因为有效串的个数为nlognnlognnlogn级别，预处理出所有变换完后的串的哈希值，每次比较即可。\n D ：\n考虑枚举二进制下1的个数，将小于的放进或集合，将大于的放进与集合，当前枚举的这一项可以放进与集合里或者是或集合里，若当前项内所有数相等，也可以拆开放进两个集合里，维护区间xorxorxor和区间andandand即可。\n 2024.9.13：\n A ：\n将所有球按标号排序，然后按照基数排序的思想分治处理即可。\n B ：\n考虑状压算出每个状态对应的可以走到的点，对于其他点用1的路径首尾连接即可凑出合法的点对。\n C ：\n考虑建ACAM或SAM，对于每个字符串k枚举所有可能的i，考虑到合法的字符串只有∣Sk∣|S_k|∣Sk​∣个，时间复杂度正确。\n 2024.9.14：\n A：\n原，8.19C\n B：\n多项式多点求值即可。\n C：\n考虑无解情况，从后往前找到第一个cnt≠0cnt≠0cnt=0的值，设sum=0sum=0sum=0每次使sum&gt;&gt;1+cnti→sumsum&gt;&gt;1+cnt_i → sumsum&gt;&gt;1+cnti​→sum，需要保证sumsumsum恒大于222，剩下的直接dp即可。\n 2024.9.16：\n A：\n三维偏序板子，离线二维数点可以做到单logloglog。\n B：\n考虑建PAMPAMPAM，建出回文链接数，树剖之后维护即可。\n C:\n将每个点的值改为ai−∑u∈soniau×bua_i-\\sum_{u∈ son_i}a_u×b_uai​−∑u∈soni​​au​×bu​，然后可以转化为阶梯博弈，将所有奇数层的SGSGSG值xorxorxor起来判零即可，注意若bi=0b_i=0bi​=0要将当前点归为奇数层，其子树按当前点计算。\n 2024.9.17：\n A：\n换根dp\n B：\n30分Floyd即可解决，100分对每个连通块找循环节，最后合并即可。\n C：\n树上无敌大粪讨吗，相当麻烦，不在这写了。\n 2024.9.18：\n A：\n唐题，倒着考虑即可。\n B：\n神秘多项式不可做题，被创飞了，谁教你放在B的。\n C：\n首先计算出 直飞成本，这个可以简单 bfs 求出。\n剩下的部分考虑 DP，记fi,xf_{i, x}fi,x​表示花费代价为iii，走到编号为xxx的岛屿最多能够乘坐多少次飞机。由于 直飞成本是曼哈顿距离，所以0≤i≤n+m0 \\leq i \\leq n+m0≤i≤n+m，岛屿数x≤n2x \\leq n^{2}x≤n2，状态数是O(n3)O\\left(n^{3}\\right)O(n3)的。\n直接枚举每个岛屿能飞到哪些岛屿，对这些岛屿之间连边，边数是O(n4)O\\left(n^{4}\\right)O(n4)的。 DP 时对每个iii进行一次转移，总时间复杂度O(n5)O\\left(n^{5}\\right)O(n5)，可以通过 subtask2。\n考虑优化建边，一对点(u,v)(u, v)(u,v)之间有边，一定满足最小的包含u,vu, vu,v的矩形内没有别的陆地，否则选择这条边转移一定不是最优的。证明如下:\n假设这个矩形内还有一个点ppp，若ppp与u,vu, vu,v均不属于同一个岛屿，那么可以花费相同的代价乘坐更多次的飞机。若ppp与u,vu, vu,v之一属于同一个岛屿（假设和uuu属于同一岛屿），那么从uuu步行到ppp然后再坐飞机代价更小。\n使用单调栈 (或者其他方法) 维护，这样边数就是O(n2)O\\left(n^{2}\\right)O(n2)的了，因为每个点最多被一条边所在的矩形覆盖。总时间复杂度是O(n3)O\\left(n^{3}\\right)O(n3)的。\nD：\n模拟题，预处理每四百年的循环节即可，比儒略日简单。\n 2024.9.19：\n A ：\n设f(x)=⌊max⁡(K/x2,K/x⌋,f(0)=+∞f(x)=\\left\\lfloor\\max \\left(K / x^{2}, \\sqrt{K / x}\\right\\rfloor, f(0)=+\\infty\\right.f(x)=⌊max(K/x2,K/x​⌋,f(0)=+∞，那么aiai+1a_{i} a_{i+1}ai​ai+1​合法当且仅当ai+1≤f(ai)a_{i+1} \\leq f\\left(a_{i}\\right)ai+1​≤f(ai​)。\n如果从iii开始的连续段长度为 1 ，那么方案数显然就是min⁡(f(ai−1),f(ai+1))+1\\min \\left(f\\left(a_{i-1}\\right), f\\left(a_{i+1}\\right)\\right)+1min(f(ai−1​),f(ai+1​))+1。\n否则，设A=f(ai−1),B=f(ai+2)A=f\\left(a_{i-1}\\right), B=f\\left(a_{i+2}\\right)A=f(ai−1​),B=f(ai+2​)，那么就要计算\n∑x=0A∑y=0B[xymin⁡(x,y)≤K]\\sum_{x=0}^{A} \\sum_{y=0}^{B}[x y \\min (x, y) \\leq K]\nx=0∑A​y=0∑B​[xymin(x,y)≤K]\n显然应该分类讨论min⁡(x,y)\\min (x, y)min(x,y)是啥，不妨假设x≤yx \\leq yx≤y。那么直接校举xxx，就是求\n∑x=0Amax⁡(0,min⁡(B,⌊K/x2⌋)−x+1)\\sum_{x=0}^{A} \\max \\left(0, \\min \\left(B,\\left\\lfloor K / x^{2}\\right\\rfloor\\right)-x+1\\right)\nx=0∑A​max(0,min(B,⌊K/x2⌋)−x+1)\n显然这是一个分三段的函数，分别对max⁡(0,⋯ )\\max (0, \\cdots)max(0,⋯)和min⁡(B,⋯ )\\min (B, \\cdots)min(B,⋯)求出分段点即可。\n但是暴力怎么96pts捏。\n B：\n直接人脑 xor 卷积看结果。两个前缀做 xor 卷积时直接 xor 起来就可以获得一个新前缀，长度就是两个前缀长度的 min 。\n容易发现做完 xor 卷积之后仍然只有O(log⁡m)O(\\log m)O(logm)个前缀，且仍然存在一个数xxx使得每个前缀除掉最后一位之后就是xxx的前缀。于是就做完了。\n C:\nLemma 1. 在最优解中，如果ki−1≤ki≥ki+1k_{i-1} \\leq k_{i} \\geq k_{i+1}ki−1​≤ki​≥ki+1​，那么必然有ki=min⁡(pi−pi−1,pi+1−pik_{i}=\\min \\left(p_{i}-p_{i-1}, p_{i+1}-p_{i}\\right.ki​=min(pi​−pi−1​,pi+1​−pi​，也就是说如果kik_{i}ki​是衱大值，那么它必然顶到了pi−1p_{i-1}pi−1​或pi+1p_{i+1}pi+1​。\n证明. 显然ki+ki−1=pi−pi−1,ki+ki+1=pi+1−pik_{i}+k_{i-1}=p_{i}-p_{i-1}, k_{i}+k_{i+1}=p_{i+1}-p_{i}ki​+ki−1​=pi​−pi−1​,ki​+ki+1​=pi+1​−pi​， 也就是两边都要相切，否则肯定不是最优解。\n不妨设0&lt;ki−1≤ki+10&lt;k_{i-1} \\leq k_{i+1}0&lt;ki−1​≤ki+1​，那么令ki−1′=0,ki′=ki+ki−1,ki+1′=ki+1−ki−1k_{i-1}^{\\prime}=0, k_{i}^{\\prime}=k_{i}+k_{i-1}, k_{i+1}^{\\prime}=k_{i+1}-k_{i-1}ki−1′​=0,ki′​=ki​+ki−1​,ki+1′​=ki+1​−ki−1​。 一波计算得\nS′−S=(ki+ki−1)2+(ki+1−ki−1)2−ki−12−ki2−ki+12=2kiki−1+ki−12−2ki+1ki−1≥ki−12&gt;0\\begin{aligned}\nS^{\\prime}-S &amp; =\\left(k_{i}+k_{i-1}\\right)^{2}+\\left(k_{i+1}-k_{i-1}\\right)^{2}-k_{i-1}^{2}-k_{i}^{2}-k_{i+1}^{2} \\\\\n&amp; =2 k_{i} k_{i-1}+k_{i-1}^{2}-2 k_{i+1} k_{i-1} \\\\\n&amp; \\geq k_{i-1}^{2} \\\\\n&amp; &gt;0\n\\end{aligned}\nS′−S​=(ki​+ki−1​)2+(ki+1​−ki−1​)2−ki−12​−ki2​−ki+12​=2ki​ki−1​+ki−12​−2ki+1​ki−1​≥ki−12​&gt;0​\n也就是把kkk替换为k′k^{\\prime}k′严格更优，与最优解矛盾。\n设li=pi−pi−1l_{i}=p_{i}-p_{i-1}li​=pi​−pi−1​。 可以看出，确定pjp_{j}pj​是极大值时，至多只能控制ki,⋯ ,kj−1k_{i}, \\cdots, k_{j-1}ki​,⋯,kj−1​，而且这恰好对应一个极长上升子段li+1,⋯ ,ljl_{i+1}, \\cdots, l_{j}li+1​,⋯,lj​（当然，也可以对应一个极长下降子段。）\n由于所有极长上升子段的长度之和是O(n)O(n)O(n)的，因此令每个pjp_{j}pj​为极大值时能推出的kkk的个数之和也是O(n)O(n)O(n)的。因此每个位置能取的kkk的个数之和也是O(n)O(n)O(n)的。\n于是就变成从O(n)O(n)O(n)个区间中选出权值和最大的不交区间集合了。\n设SiS_{i}Si​表示iii这个位置对应的区问集合。由于还满足Si−1S_{i-1}Si−1​和SiS_{i}Si​的区间两两不交，所以从左往右进行一个简单 DP 即可。\n场上想出来但是挂分了。\n 2024.9.20：\n A ：\n可以一眼看出是数论分块，不过怎么挂分了/kk\n B ：\n考虑到斐波那契有效项比较小，每次枚举，并选出符合条件的x和y，这个可以用exgcd解决，时间复杂度单log。\n C ：\n考虑二分最短路，每次check遍历每一条边，检验是否可以将最短路增加到此长度即可。\n D ：\n还是二分答案，既然想要最大速度尽量的小，那我们就一定要让每一个人的烟花都燃烧完，让点燃的时间最长。\n于此同时，让最大速度尽量小的第二点，就是让人们两两之间的距离尽量小，所以需要我们让所有人都尽量靠近那个烟花正在燃烧的人。\n由于他们之间的距离是确定的，且每个人的速度也由二分答案枚举而确定，所以我们可以将他们之间的距离变成时间。\n为了尽量压缩所枚举人的时间，我们将每一部分人当作一个集合。\n从现在拿烟花的那个人开始，左边第一个可以使他烟花然烧时间变长的人与他之间的一段人为一个集合，记录下这一集合中能使他增长的时间以及需要的时间，就是这个过程他烟火时间最少的时间。\n由此，多次同样的操作。\n注意的是，如果这个时间有集合可以选择，就一定要先看集合。\n最后还剩一段时，原理相同，用相反的方法即可。\n 2024.9.23：\n A ：\n树形dp，需要维护子树颜色数量最大值，直接上dsu即可，差不多n log nn\\ log\\ nn log n。\n B ：\n总共两种做法，一种是对每条 spark 边界线，看其他 spark 是否覆盖掉了它在游戏区域内的所有区段，如果没有覆盖完，则说明有安定点， 这样就是一个线段覆盖问题； 另外一种就是把所有交点求出来，然后扫描线 + 点事件来 维护所有 spark 边界线的上下位置，然后维护一个前缀和之类的 来看中间是否有空隙。\n C ：\n首先对于每一个位置，经过若干次操作之后会变成kpkp−1′′k_{p}^{k_{p-1}^{\\prime \\prime}}kpkp−1′′​​的形式，从最底层开始套用拓展欧拉定理，则经过O(log⁡P)\\mathrm{O}(\\log P)O(logP)层，模数就变成 1 了，所以更上面的数字就设有意义了，暴力的做法就是对于每个位置维护一个O(log⁡P)\\mathrm{O}(\\log P)O(logP)的常塔。\n进一步分析，对于一段区间，如果对其进行O(log⁡P)\\mathrm{O}(\\log P)O(logP)次相同的修改操作，最后这段区间所有位置就会等价，我们就可以合并这段区间。\n所以考虑给n−1n-1n−1个间隔设置势能，一次[l,r][l, r][l,r]的区间修改可以把[l,r][l, r][l,r]内的间隔的势能都减去 1 ，然后把l−1l-1l−1到lll和rrr到r+1r+1r+1这两个间隔的势能加上O(log⁡P)O(\\log P)O(logP)。\n可以用线段树加 set 或者 splay 来维护每个间隔的势能，以及合并等价区段。这部分的复杂度即为O(nlog⁡nlog⁡P)O(n \\log n \\log P)O(nlognlogP)。\n基于以上的分析，我们需要进行O(nlog⁡P)\\mathrm{O}(n \\log P)O(nlogP)次常塔结果计算，也即需要计算O(nlog⁡2P)\\mathrm{O}\\left(n \\log ^{2} P\\right)O(nlog2P)次快速幂，所以我们希望可以快速地计算快速幂。\n这里因为PPP较小，且只会有O(log⁡P)O(\\log P)O(logP)种有用的模数，更关键的是因为欧拉函数每迭代两次就至少会把一个数变成一半。所以考虑对每个模数下的每个数字的幂次结果进行类似 BSGS 的预处理，可知复杂度为：\nO(P32+(P2)32+⋯ )=O(P32)\\mathrm{O}\\left(P^{\\frac{3}{2}}+\\left(\\frac{P}{2}\\right)^{\\frac{3}{2}}+\\cdots\\right)=\\mathrm{O}\\left(P^{\\frac{3}{2}}\\right)\nO(P23​+(2P​)23​+⋯)=O(P23​)\n这样算一次快速幂就可以做到O(1)\\mathrm{O}(1)O(1)了。时间复杂度:O(n(log⁡n+log⁡P)log⁡P+P32)\\mathrm{O}\\left(n(\\log n+\\log P) \\log P+P^{\\frac{3}{2}}\\right)O(n(logn+logP)logP+P23​)。\n 2024.9.24：\n A：\nSub1\n维护区间加法，查询区间≤k\\leq k≤k个数。\n考虑分块，每个块维护一个加法标记，每次修改对于块进行排序。\n\n\n容易发现修改之后，一定是一部分数增加kkk，一部分数不变，将这两部分归并即可完成线性排序。\n\n\n查询≤k\\leq k≤k的个数，可以通过离线，排序询问，就能将二分的过程转化为维护一个指针。值域只有10710^{7}107是为了方便选手进行询问的排序。\n\n\nSub2\n求S(n,m)=∑i=0m(ni)S(n, m)=\\sum_{i=0}^{m}\\binom{n}{i}S(n,m)=∑i=0m​(in​)\n由S(n,m)=S(n,m−1)+(nm),S(n+1,m)=2S(n,m)−(nm)S(n, m)=S(n, m-1)+\\binom{n}{m}, S(n+1, m)=2 S(n, m)-\\binom{n}{m}S(n,m)=S(n,m−1)+(mn​),S(n+1,m)=2S(n,m)−(mn​)，可以用简单莫队维护。\n B：\n结论 : 一个块大小kkk是合法的，当且仅当树上有nk\\frac{n}{k}kn​个节点的 size 是kkk的倍数。\n C：\nf′(θ)=b−ahcos⁡θsin⁡2θf^{\\prime}(\\theta)=b-\\frac{a h \\cos \\theta}{\\sin ^{2} \\theta}\nf′(θ)=b−sin2θahcosθ​\n由于cos⁡θ\\cos \\thetacosθ在DDD上递减，sin⁡θ\\sin \\thetasinθ在DDD上递增，容易发现f′(θ)f^{\\prime}(\\theta)f′(θ)在DDD上单调递增。\n由此得到f(θ)f(\\theta)f(θ)有唯一最小值 。\n设x=cos⁡θx=\\cos \\thetax=cosθ，则极值点f′(θ)=b−ahx1−x2=0f^{\\prime}(\\theta)=b-\\frac{a h x}{1-x^{2}}=0f′(θ)=b−1−x2ahx​=0\nb(1−x2)=ahxbx2+ahx−b=0\\begin{array}{c}\nb\\left(1-x^{2}\\right)=a h x \\\\\nb x^{2}+a h x-b=0\n\\end{array}\nb(1−x2)=ahxbx2+ahx−b=0​\n解这个方程得到cos⁡θ\\cos \\thetacosθ，然后得到θ\\thetaθ，可以O(1)O(1)O(1)回答询问。\n D：\n容易发现答案一定包含直径的某一个端点，枚举是哪一个端点，以这个端点为根，建一棵树，然后对这棵树进行长链剖分。\n此时，答案一定是选择了 根到达一个叶子的路径，以及k−1k-1k−1对叶子，也就可以看成是选了2k−12 k-12k−1个叶子。\n此时，我们贪心地来选择叶子，一个叶子的贡献为它与它所在链顶端的点的距离。\n此时我们只需要选出贡献最大的2k−12 k-12k−1个叶子，容易证明一定存在使得这种贪心合法的方案。\n接下来考虑必须经过首都的限制，将叶子按照贡献的从大到小排序，令hxh_{x}hx​为xxx子树内叶子排名的最小值。\n此时对于一个点xxx，若h(x)≤2k−1h(x) \\leq 2 k-1h(x)≤2k−1，此时直接众心的方案合法。\n否则我们要把一个叶子换成xxx子树内的叶子。\n假设换掉了叶子yyy，\n\n\n若yyy的顶端不是xxx的祖先，那么我们换掉它的代价就是yyy的贡献。\n\n\n否则换掉它的代价就是yyy到LCA(x,y)\\mathrm{LCA}(x, y)LCA(x,y)的距离。\n\n\n对于第一种情况直接换掉贡献最小的叶子，对于第二种情况可以用倍增解决。\n 2024.9.25：\n A：\n考虑在方格表上二分。\n第一轮，先间问整个方格表最中间的两行，末间问方格组成上下两部分，考察这两行的最小值xxx，如果这个最小值在两行中的上面一行，那么 1 的位置一定在上面部分，反之则在下面部分。\n第二轮，不妨设 1 在上面部分，询问上面部分最中间的两个半列，目前可能出现 1 的末间问方格组成左右两部分。\n还是考虑这两个半列的最小值yyy，不妨设yyy在两个半列中左边的半列。\n如果y&lt;xy&lt;xy&lt;x，那么 1 的位置在左面部分，反之则右， 1 的位置在与xxx相邻的那部分。\n以此类准，每次可以把 1 的位置限定在全局间问过的方格的最小值的相邻部分，总询问次数为2×(2n+n+n2⋯ )−2n=6n2 \\times\\left(2 n+n+\\frac{n}{2} \\cdots\\right)-2 n=6 n2×(2n+n+2n​⋯)−2n=6n，能拿55分，考虑继续优化 。\n进一步发现，我们并不需要知道两行的最小值，只需要先询问一行的最小值，再在这个最小值上下找到比该最小值更小的一个值， 1 的位置也随之确定了，于是总询问次数降低到n+n2+n2+n4⋯=3nn+\\frac{n}{2}+\\frac{n}{2}+\\frac{n}{4} \\cdots=3 nn+2n​+2n​+4n​⋯=3n，期望得分 100 。\n B:\n容易发现一个非常简单的n=2k+1n=2 k+1n=2k+1的构造，即任意选择p1p_{1}p1​，并取pi+k=pi+1( mod n)p_{i}+k=p_{i+1}(\\bmod n)pi​+k=pi+1​(modn)，容易验证其正确性，并且其有重要性质∣pn−p1∣∈{k,k+1}\\left|p_{n}-p_{1}\\right| \\in\\{k, k+1\\}∣pn​−p1​∣∈{k,k+1}。\n将序列反转可以知道，可以任意选择满足∣pn−p1∣∈{k,k+1}\\left|p_{n}-p_{1}\\right| \\in\\{k, k+1\\}∣pn​−p1​∣∈{k,k+1}并且在范围内的p1,pnp_{1}, p_{n}p1​,pn​，都有满足条件的构造。\n如果在上述构造中取p1=0p_{1}=0p1​=0，并且在序列最后加上2k+12 k+12k+1，我们得到了一个n=2k+2n=2 k+2n=2k+2的构造，但这个构造没有更好的性质。\n设2k+12 k+12k+1的构造在p1=x,pn=yp_{1}=x, p_{n}=yp1​=x,pn​=y时为A(x,y),2k+2A(x, y), 2 k+2A(x,y),2k+2的构造为B(x,y)B(x, y)B(x,y)。\n发现当nnn巨大的时侯，可以使用不超过2k+12 k+12k+1个BBB以及很多个AAA来拼接出nnn的均造，现在只需要满足其两段拼接处的条件，容易发现两个AAA之间的拼接由于AAA自由度高，比较容易，需要找出一种方案能将两个BBB连接在一起。\n考虑如下构造，设当前的BBB为B(a,a+2k+1)B(a, a+2 k+1)B(a,a+2k+1)，可以构造B(a,a+2k+1)−A(a+3k+1,a+4k+1)−A(a+5k+1,a+6k+1)−⋯−A(a+2k2−k+1,a+2k2+1)−B(a+2k2+k+1,a+2k2+3k+2)B(a, a+2 k+1)-A(a+3 k+1, a+4 k+1)-A(a+5 k+1, a+6 k+1)-\\cdots-A\\left(a+2 k^{2}-k+1, a+2 k^{2}+1\\right)-B\\left(a+2 k^{2}+k+1, a+2 k^{2}+3 k+2\\right)B(a,a+2k+1)−A(a+3k+1,a+4k+1)−A(a+5k+1,a+6k+1)−⋯−A(a+2k2−k+1,a+2k2+1)−B(a+2k2+k+1,a+2k2+3k+2)最后一个AAA对应的均造中最大数为a+2k2+ka+2 k^{2}+ka+2k2+k，可以拼接上。这里的所有构造值域均是相接的，可以计算脸证。\n于是我们用k−1k-1k−1个AAA将相邻两个BBB连接了起来，多余的AAA可以简单排列在最后一个BBB之后。\n通过计算知道这样的构造方法能勾造成功的nnn下界为4k3+O(k2)4 k^{3}+O\\left(k^{2}\\right)4k3+O(k2)，可以通过。\n C：\n考虑(u,fau)\\left(u, f a_{u}\\right)(u,fau​)关于[l,r][l, r][l,r]好的条件，转化为uuu子树内有[l,r][l, r][l,r]之间的点且uuu并不是lca(l,l+1…r)l c a(l, l+1 \\ldots r)lca(l,l+1…r)本身或其祖先，其中后面条件可以容压掉，只需要減去询问区间的所有子区间 lca 深度和即可。\n现在计算单个区间权值軴化为两个问题：区间 lca 深度，有多少个子树内有该区间之间的点。\n-区间 lca 深度。\n即解决询问区间子区间 lca 深度和，考虑扫描右端点，维护所有左端点对应 lca 深度，并维护历史和。 修改一段左端点区间的对应 lca，实现区间加区间历史和，修改次数均摊线性。这一部分是O(nlog⁡n)O(n \\log n)O(nlogn)的。\n-有多少个子树内有该区间之间的点\n考察一个点uuu不计入[l,r][l, r][l,r]答穼的时候，将uuu子树内点按编号排序，那么这个[l,r][l, r][l,r]一定是介于两个编号排序后相邻的点之间的，可以抽象成知形加。\n考虑树上启发式合并，对每个子树维护一个 set 或一棵平衡树之类，内部存子树内点的编号，每次把小子树的某点合并到大子树里的时候，将大子树对应平衡树中该点编号前驱后继取出，并将这个矩形加终止，换用新的两个矩形加。\n问题变为O(nlog⁡n)O(n \\log n)O(nlogn)次矩形加，询问即为矩形查询，可以在O(nlog⁡2n)O\\left(n \\log ^{2} n\\right)O(nlog2n)的时间内得到解决。\n 2024.9.26：\n A：\n将所有区间按lil_{i}li​从小到大排序，一个一个贪心加入，加入的时候有两种情况：\n\n\n之前的区间中存在未匹配的区间，且可以跟当前区间匹配。由于之后的区间的lll都不会小于当前区间的lll，我们陏便选择一个区间跟当前区间匹配即可。\n\n\n找不到可以跟当前区间匹配的末匹配的区间。我们在已经匹配的区间对(i,j)(i, j)(i,j)中找到rjr_{j}rj​最小的一个区间对，如果rjr_{j}rj​比当前区间的rrr小，我们可以交换这两个区间，让iii跟当前区间匹配，把jjj变成未匹配区间。\n\n\n容易发现这样贪心是最优的，用两个堆分别维护未匹配区间和已匹配区间即可，复杂度O(nlog⁡n)O(n \\log n)O(nlogn)。\n B：\n注意到如果区间l,rl, rl,r中有&gt;log⁡106&gt;\\log 10^{6}&gt;log106个aia_{i}ai​满足ai≥x2a_{i} \\geq \\frac{x}{2}ai​≥2x​，这个区间的答案就是 0 ，因比我们只需要对log⁡106\\log 10^{6}log106个区间求出∏i=lrx−aix\\prod_{i=l}^{r} \\frac{x-a_{i}}{x}∏i=lr​xx−ai​​，这些区间中的aia_{i}ai​都满足ai&lt;x2a_{i}&lt;\\frac{x}{2}ai​&lt;2x​。\n我们可以考虑如何求出∑i=lrln⁡(x−aix)\\sum_{i=l}^{r} \\ln \\left(\\frac{x-a_{i}}{x}\\right)∑i=lr​ln(xx−ai​​)，最后exp⁡\\expexp一下就可以得到结果，我们对前面的式子进行展开:\nln⁡(x−aix)=ln⁡(1−aix)=−∑j&gt;0(aix)j⋅1j\\begin{array}{c}\n\\ln \\left(\\frac{x-a_{i}}{x}\\right)=\\ln \\left(1-\\frac{a_{i}}{x}\\right) \\\\\n=-\\sum_{j&gt;0}\\left(\\frac{a_{i}}{x}\\right)^{j} \\cdot \\frac{1}{j}\n\\end{array}\nln(xx−ai​​)=ln(1−xai​​)=−∑j&gt;0​(xai​​)j⋅j1​​\n注意到aix&lt;12，(aix)j\\frac{a_{i}}{x}&lt;\\frac{1}{2} ，\\left(\\frac{a_{i}}{x}\\right)^{j}xai​​&lt;21​，(xai​​)j很快就会变成 0 ，我们只要对前几个jjj计算这个式子即可，对每个jjj预处理aij\\frac{a_{i}}{j}jai​​的前缀和即可，复杂度O((n+q)log⁡106)O\\left((n+q) \\log 10^{6}\\right)O((n+q)log106)。\n C：\n\n\n先手选择长度为1/21 / 21/2的链，后手获得链上的格子，交换先后手。\n\n\n先手选择一条链/一个环，后手选择交换先后手/先后手不变，并获得相应的分数。\n\n\n容易发现的性质是，先手选择的链/环一定是当前的链/环中长度最小的，因此我们可以设dpi,jd p_{i, j}dpi,j​表示当前只剩下最大的iii条链，jjj个环，此时先手得分減后手得分的最大值是多少，可以从dpi+1,jd p_{i+1, j}dpi+1,j​和dpi,j+1d p_{i, j+1}dpi,j+1​转移过来。\n由于链的两端一定在边界处，最多只有n+mn+mn+m条链，复杂度O(nm(n+m))O(n m(n+m))O(nm(n+m))。\n D：\n我们可以把i⊕j⊕xi \\oplus j \\oplus xi⊕j⊕x拆成log⁡\\loglog个区间，我们只需要对每个区间求出∑i=lrf(i)\\sum_{i=l}^{r} f(i)∑i=lr​f(i)即可。\nF0(x)=1Fk(x)=∏i=0x(2i+1)( mod 2k)\\begin{array}{c}\nF_{0}(x)=1 \\\\\nF_{k}(x)=\\prod_{i=0}^{x}(2 i+1) \\quad\\left(\\bmod 2^{k}\\right)\n\\end{array}\nF0​(x)=1Fk​(x)=∏i=0x​(2i+1)(mod2k)​\n我们可以得到：\nFk+1(x)=2x⋅Fk(x−1)+Fk+1(x−1)Fk+1(x)−Fk+1(x−1)=2x⋅Fk(x−1)\\begin{array}{l}\nF_{k+1}(x)=2 x \\cdot F_{k}(x-1)+F_{k+1}(x-1) \\\\\nF_{k+1}(x)-F_{k+1}(x-1)=2 x \\cdot F_{k}(x-1)\n\\end{array}\nFk+1​(x)=2x⋅Fk​(x−1)+Fk+1​(x−1)Fk+1​(x)−Fk+1​(x−1)=2x⋅Fk​(x−1)​\n可以发现Fk(x)F_{k}(x)Fk​(x)是一个关于xxx的2k−22 k-22k−2次多项式，那么我们要求的就是∑i=lrF32(i)\\sum_{i=l}^{r} F_{32}(i)∑i=lr​F32​(i)，它是一个 63 次多项式，可以直接拉格朗日插值，在插值过程中需要注意将 2 的次幂提出来特殊处理，复杂度O(63log⁡n)O(63 \\log n)O(63logn)。\n 2024.9.27：\n A：\n考虑对于一个点权和s(s≥3)s(s \\geq 3)s(s≥3)的连通块，先将其所有点权为 0 的叶子删去，则:\n\n\n若存在点权为 2 的叶子，将其删去可得到点权和为s−2s-2s−2的连通块；\n\n\n否则所有叶子点权为 1 ，删去两个叶子可得到点权和为s−2s-2s−2的连通块。\n\n\n所以设fi,0/1f_{i, 0 / 1}fi,0/1​表示iii子树内包含iii的连通块为奇数/偶数的最大点权和。\n从下至上贪心，若fi,k mod 2≥kf_{i, k} \\bmod 2 \\geq kfi,k​mod2≥k则直接截取该连通块，之后就不考虑iii子树了，时间复杂度O(n)O(n)O(n)。\n B：\n考虑折半搜索，枚举kx+bk x+bkx+b的高 15 位，那么可以得知其低 15 位模kkk的值和其下界，时间复杂度O(TS)O(T \\sqrt{S})O(TS​)。\n C：\n首先我们知道，存在四元环等价于存在两个点存在至少两个公共邻居。\n枚举这个公共邻居的贡献直到找到四元环，就可以O(n2)O\\left(n^{2}\\right)O(n2)判四元环存在性了。\n考虑修改边，把所有没有被修改的边拿出来判四元环。如果存在那么所有答案都是 Yes。否则可以预处理出任意两点的公共邻居数量。\n时间复杂度O(n2+nq)O\\left(n^{2}+n q\\right)O(n2+nq)。\n D：\n来源：AtCoder World Tour Finals 2024 C\n不会，直接贺官解。\n我们不会加多余的燃料。所以如果移动的距离是lll，那么答案就是max⁡(l−2C,0)\\max (l-2 C, 0)max(l−2C,0)。只需要考虑最小化移动距离。\n那么到一个加油站之后必定会加满这种类型的燃料。设另一种燃料的剩余量为xxx。\n考虑从一个加油站行驶到一个与其距离为aaa的加油站，显然有\n\n\n如果两者燃料类型相同，x←x−max⁡(a−C,0)x \\leftarrow x-\\max (a-C, 0)x←x−max(a−C,0)\n\n\n如果两者燃料类型不同，x←min⁡(x+C−a,C)x \\leftarrow \\min (x+C-a, C)x←min(x+C−a,C)\n\n\n限制是始终有x≥0x \\geq 0x≥0。\n考虑一个 dp 表示到第iii个加油站时x=jx=jx=j的最小折返总距离。可以发现只可能从iii转移到i+1i+1i+1。\n如果移动之后xxx不会增加那直接转移即可。否则我们可能会在这里刷xxx。具体来说，可以每次以2a2 a2a的代价增加2(C−a)2(C-a)2(C−a)的xxx。\n考虑这个 dp 数组长什么样子，大概是，你考虑有用的位置，可以分成若干段，每一段里面的下标和值都是一个等差数列。下标的公差是某个2(C−a)2(C-a)2(C−a)，值的公差是某个2a2 a2a。而且越靠后aaa越大。\n可以发现这里aaa比较小是严格比aaa比较大好的。所以进行一个aaa的转移的时候，会把后面的若干个等差数列弹掉，然后取出最后一个有用的位置（如果全部弹了就是原本的第一个）往后更新一个等差数列。\n用个 deque 维护就是O(n)O(n)O(n)的，然而可能xxx超出了CCC得取min⁡\\minmin了，那相当于从这个位置重新出发了。\n从每个位置开始 dp一次即可，时间复杂度O(n2)O\\left(n^{2}\\right)O(n2)。\n 2024.9.29：\n A：\n容易发现，能力值最大的人一定能胜利。而其它人要胜利，就一定要打败最大值,于是想到最值分治。\n考察当前序列最大值 (设位置为 mid）左边的一个数，它要胜利，一定要把最大值打败。\n而我们发现，在打败最大值之前先把最大值左边的所有数全部打败，总是不劣的：要是打完前已经达到最大值了，那无论如何都可以。要是打完前达不到最大值，只能先打弱者增加能力值。\n因此，对下标为[1,mid−1][1, m i d-1][1,mid−1]的人，他能赢的充要条件是: 能打完[1，mid−1][1 ，mid -1 ][1，mid−1]内的所有人，且能力值至少是amid−(mid−1)a_{m i d}-(m i d-1)amid​−(mid−1)。\n可以设计递归函数Solve⁡(l,r,v)\\operatorname{Solve}(l, r, v)Solve(l,r,v)，表示对于下标为[l,r][l, r][l,r]内的人，他能赢的充要条件是能打赢区间内的人，且下标至少为vvv，递归到l=rl=rl=r就得到了每个人能不能赢。\n对序列建大根笛卡尔树，就可以将上述过程做到线性，最后加上区间dpdpdp即可。\n B：\n考虑容斥，钦定kkk个下㮏满足ai&lt;ai+1a_{i}&lt;a_{i+1}ai​&lt;ai+1​，剩下的可以≥\\geq≥也可以&lt;，&lt;，&lt;，。\n可以发现，这时相当于将序列分为了n−kn-kn−k段，每段内部都是严格递增的。\n也就是说，如果确定了每段内部数的集合，就能唯一构造出一个排列。那考虑对每段内部的集合计数，考虑将每个数填入每一段里。\n若iii在序列中出现了cntic n t_{i}cnti​次，它填入n−kn-kn−k段的方案数就是(cntin−k)\\binom{c n t_{i}}{n-k}(n−kcnti​​)。\n因此，我们要求的就是Π(cntin−k)……\\Pi\\binom{c n t_{i}}{n-k} \\ldots \\ldotsΠ(n−kcnti​​)……. 吗?\n上述填法有可能出现空段，为了避免空段，我们需要对算出的乘积再容斥一次。两次容斥都可以直接用卷积实现。\n考虑如何计算乘积，注意到cntc n tcnt至多只有O(n)O(\\sqrt{n})O(n​)种，对每种cntc n tcnt可以O(1)O(1)O(1)算出组合数，然后用快速幕就可以算出该种cntc n tcnt的答案。\n C：\n首先用线段树优化建图，对线段树上每个区间，维护区间内\n\n\n矩阵上为 0 的位置的入树\n\n\n矩阵上为 0 的位置的出树\n\n\n矩阵上为 1 的位置的入树\n\n\n矩阵上为 1 的位置的出树\n\n\n用扫描线处理修改操作，打标记时就是交换 0，1 位置的对应树，上传信息时需要新建结点。\n然后缩点，将所有点划分为强连通分量，并将强连通分量拓扑排序。\n熟知的结论是，竞赛图的强连通分量排成一条链，而我们希望二分完全图的强连通分量最好也有类似的简单结构。\n设强连通分量按正拓扑序排列，为A1,…,AkA_{1}, \\ldots, A_{k}A1​,…,Ak​。\n经过分析，不难发现以下规律:\n\n\n若∣A1∣=1\\left|A_{1}\\right|=1∣A1​∣=1，设PPP为最大的ppp，使得∣A1∣=∣A2∣=⋯=∣Ap∣=1\\left|A_{1}\\right|=\\left|A_{2}\\right|=\\cdots=\\left|A_{p}\\right|=1∣A1​∣=∣A2​∣=⋯=∣Ap​∣=1，且A1,A2,…,ApA_{1}, A_{2}, \\ldots, A_{p}A1​,A2​,…,Ap​全部在二分图的同一侧，则A1,A2,…,APA_{1}, A_{2}, \\ldots, A_{P}A1​,A2​,…,AP​互不可达，且全部可达AP+1,…,AkA_{P+1}, \\ldots, A_{k}AP+1​,…,Ak​。\n\n\n否则，A1A_{1}A1​可达全部的A2,…,AkA_{2}, \\ldots, A_{k}A2​,…,Ak​。\n\n\n直接分类讨论即可证明上述结论。\n据此，缩点后可以O(n+m)O(n+m)O(n+m)求出每个点可达多少点。\n 2024.9.30：\n A：\n考场上想到区间dp了，但是没想到dp状态要加第三维。\n假设 1 在aaa中的位置为ppp，在bbb中位置为qqq，由于 1 始终是堆中最后一个被取出的数，所以显然有q≥pq \\geq pq≥p，并且取出 1 后堆一定是空的，也就是说aaa的前qqq个数和bbb的前qqq个数的集合应该是一样的。\n此时我们可以递归下去，因为[q+1,n][q+1, n][q+1,n]和[1,q][1, q][1,q]（但去掉 1 ）这两个aaa中的段是独立的，再分别考虑其中的最小值即可。\n据此可以区间 DP 。设dp(l,r,v)d p(l, r, v)dp(l,r,v)表示只考虑下标区间[l,r][l, r][l,r]中≥v\\geq v≥v的数时的答案，那么ans=dp(1,n,1)a n s=d p(1, n, 1)ans=dp(1,n,1)，通过枚举最小值的位置来转移。\n","categories":["总结"],"tags":["考试总结"]},{"title":"课件","url":"/2024/10/02/%E8%AF%BE%E4%BB%B6/","content":" Before：\nemmm返校的时候被告知讲课提前了，所以就有了这个课件。\n这次主要讲一些很基础的东西啊（可能也有进阶），因为没有太多时间准备。\n叠个甲：因为时间紧任务重部分课件是昨天手打的部分课件是昨天贺的所以可能错误一大堆而且因为我不写题解所以 Latex 可能用的稀巴烂还请谅解。\n 递推：\nbro为什么要讲这个啊，大家不是都会吗。\n这玩意 oi-wiki 上都没有分类。\n只讲一道题（因为确实不知道这有什么可讲的）：\n U485473 逆序对\n这是我们昨天考试题中的一道神秘生成函数题，取了其中的部分分当作弱化版。\n 题意：\nTTT组洵问，每组洵问给定两个数n,mn, mn,m，保证m≤nm \\leq nm≤n，试计算长为nnn，逆序对数为mmm的排列个数。答案对 998244353 取模。\n数据范围：n,m≤1e3n,m \\leq 1e3n,m≤1e3。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n没错这道题要求的逆序对数和nnn是一个数量级的。\n设初始序列为空，我们从小到大插入，考虑到第iii个数被插入时共有iii个可选位置 且序列中的数均小于iii，所以可以产生[0,i−1][0,i-1][0,i−1]个逆序对。\n考虑dp，设fi,jf_{i,j}fi,j​ 为当前已经插入了iii个数，已经产生了jjj个逆序对的方案数，由于每个状态只会从前面一个长度至多为iii 的区间里转移，所以可以用双指针优化，询问时直接输出fn,mf_{n,m}fn,m​即可，时空复杂度均为n2n^2n2。\n#include &lt;bits/stdc++.h&gt;using namespace std;#define file(x) freopen(#x &quot;.in&quot;, &quot;r&quot;, stdin), freopen(#x &quot;.out&quot;, &quot;w&quot;, stdout)#define int long longconst int N = 1e3 + 10, mod = 998244353;int T, n, m;int f[N][N];void add(int &amp;x, int y) &#123; x = x + y &gt; mod ? x + y - mod : x + y; &#125;void mis(int &amp;x, int y) &#123; x = x - y &lt; 0 ? x - y + mod : x - y; &#125;signed main()&#123;    ios::sync_with_stdio(false);    cin &gt;&gt; T;    int tp = 1000;    f[0][0] = 1;    for (int i = 1; i &lt;= tp; ++i)    &#123;        int len = i - 1, l = 0, sum = 0;        for (int j = 0; j &lt;= tp; ++j)        &#123;            add(sum, f[i - 1][j]);            while (j - len &gt; l)                mis(sum, f[i - 1][l]), ++l;            add(f[i][j], sum);        &#125;    &#125;    while (T--)        cin &gt;&gt; n &gt;&gt; m, cout &lt;&lt; f[n][m] &lt;&lt; endl;    return 0;&#125;\n没有下面了，例题就这一道。\n 递归：\n唔…这部分给点注意事项吧，知识点你们也都会：\n\n写递归（尤其是爆搜）时格外要注意有没有超栈空间，比如在递归函数的参数中传入一个 STL 或字符串什么的就很容易爆栈，建议使用可撤销的全局变量来替代。\n注意边界\n递推好写的就写递推，递归自带大常数对时间复杂度影响很大，不过像数位 dp 这种明显搜索好写且不容易错的就写递归吧。\n\n剩下的就没什么了，大家自己经验也很多，没有例题。\n 贪心：\n P2123 皇后游戏\n 题目描述：\n皇后有nnn位大臣，每位大臣的左右手上面分别写上了一个正整数。恰逢国庆节来临，皇后决定为nnn位大臣颁发奖金，其中第iii位大臣所获得的奖金数目为第i−1i - 1i−1位大臣所获得奖金数目与前iii位大臣左手上的数的和的较大值再加上第iii位大臣右手上的数。\n形式化地讲：我们设第iii位大臣左手上的正整数为aia_iai​，右手上的正整数为bib_ibi​，则第iii位大臣获得的奖金数目为cic_ici​可以表达为：\nci={a1+b1,i=1max⁡{ci−1,∑j=1iaj}+bi,2≤i≤nc_{i} = \\begin{cases} a_{1}+b_{1}  &amp; ,i=1 \\\\ \\displaystyle \\max \\left \\{ c_{i-1},\\sum_{j=1}^{i}a_{j} \\right \\} +b_{i} &amp; ,2\\leq i \\leq n \\end{cases} % ![](https://cdn.luogu.com.cn/upload/pic/1257.png)\nci​=⎩⎪⎪⎪⎨⎪⎪⎪⎧​a1​+b1​max{ci−1​,j=1∑i​aj​}+bi​​,i=1,2≤i≤n​\n当然，吝啬的皇后并不希望太多的奖金被发给大臣，所以她想请你来重新安排一下队伍的顺序，使得获得奖金最多的大臣，所获奖金数目尽可能的少。\n注意：重新安排队伍并不意味着一定要打乱顺序，我们允许不改变任何一位大臣的位置。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n也是经典例题国王游戏的改编。\n先考虑微扰贪心，对于两个大臣i,j=i+1i, j=i+1i,j=i+1，假设现在的顺序是最优顺序，那么记 last=ci−1=c_{i-1}=ci−1​，sum=∑k=1i−1ak=\\sum_{k=1}^{i-1} a_{k}=∑k=1i−1​ak​有：\ncost⁡1=max⁡{ last +bi, sum +ai+bi, sum +ai+aj}+bj\\operatorname{cost}_{1}=\\max \\left\\{\\text { last }+b_{i}, \\text { sum }+a_{i}+b_{i}, \\text { sum }+a_{i}+a_{j}\\right\\}+b_{j}\ncost1​=max{ last +bi​, sum +ai​+bi​, sum +ai​+aj​}+bj​\n交换i,ji, ji,j之后：\n cost 2=max⁡{ last +bj, sum +aj+bj, sum +aj+ai}+bi\\text { cost }_{2}=\\max \\left\\{\\text { last }+b_{j}, \\text { sum }+a_{j}+b_{j}, \\text { sum }+a_{j}+a_{i}\\right\\}+b_{i}\n cost 2​=max{ last +bj​, sum +aj​+bj​, sum +aj​+ai​}+bi​\n根据假设有：\n cost 1≤ cost 2\\text { cost }_{1} \\leq \\text { cost }_{2}\n cost 1​≤ cost 2​\n简单分讨一下我们发现第一项是没用的，所以可以改写上式：\nmax⁡{sum⁡+ai+bi,sum⁡+ai+aj}+bj≤max⁡{sum⁡+aj+bj,sum⁡+aj+ai}+bi\\max \\left\\{\\operatorname{sum}+a_{i}+b_{i}, \\operatorname{sum}+a_{i}+a_{j}\\right\\}+b_{j} \\leq \\max \\left\\{\\operatorname{sum}+a_{j}+b_{j}, \\operatorname{sum}+a_{j}+a_{i}\\right\\}+b_{i}\nmax{sum+ai​+bi​,sum+ai​+aj​}+bj​≤max{sum+aj​+bj​,sum+aj​+ai​}+bi​\nmax 里的东西提出来，移项：\nmax⁡{bi,aj}−aj−bi≤max⁡{bj,ai}−ai−bj\\max \\left\\{b_{i}, a_{j}\\right\\}-a_{j}-b_{i} \\leq \\max \\left\\{b_{j}, a_{i}\\right\\}-a_{i}-b_{j}\nmax{bi​,aj​}−aj​−bi​≤max{bj​,ai​}−ai​−bj​\n两边比较对称，所以分讨一边：\nbi&lt;aj 时，左式 =−bibi&gt;aj 时，左式 =−aj\\begin{array}{l}\nb_{i}&lt;a_{j} \\text { 时，左式 }=-b_{i} \\\\\nb_{i}&gt;a_{j} \\text { 时，左式 }=-a_{j}\n\\end{array}\nbi​&lt;aj​ 时，左式 =−bi​bi​&gt;aj​ 时，左式 =−aj​​\n所以原式化为:\nmin⁡{bi,aj}≥min⁡{bj,ai}\\min \\left\\{b_{i}, a_{j}\\right\\} \\geq \\min \\left\\{b_{j}, a_{i}\\right\\}\nmin{bi​,aj​}≥min{bj​,ai​}\n但是这只是相邻的情况，且该关系不具有传递性，而本题排序要求的是任意两元素的关系，所以不能直接用。\n所以我们的目的是将下标相同的项放在不等式同一侧。\n回到原题，一种朴素的贪心策略是尽量把aaa小bbb大的放在前面，那么可以根据这个性质展开分讨：\nai&lt;bi,aj&lt;bj(1)a_{i}&lt;b_{i}, a_{j}&lt;b_{j}(1)ai​&lt;bi​,aj​&lt;bj​(1)按aaa升序。\nai=bi,aj=bj(2)a_{i}=b_{i}, a_{j}=b_{j}(2)ai​=bi​,aj​=bj​(2)这个随便排就行了，对答案没有影响。\nai&gt;bi,aj&gt;bja_{i}&gt;b_{i}, a_{j}&gt;b_{j}ai​&gt;bi​,aj​&gt;bj​(3) 按bbb降序。\n我们按这三种特殊情况内部排完序，考虑他们之间的顺序: (1) 比 (2) 优，(3) 比 (2) 劣。\n然后就完事了。\n 反悔贪心：\n在贪心的过程中我们可能会因选择局部最优解而错过全局最优解，类似于爬山算法在多峰函数上的局限性，于是我们在决策时不断对前面的贪心进行撤销来保证选择的一定为全局最优解，这就是反悔贪心。\n总的来说：反悔操作指的是这一步的贪心不是全局最优解，我们就退回去一步（人工或自动判断），换一种贪心策略。\n按照判断方式的不同可以分为反悔自动机和反悔堆两种方法：\n\n反悔自动机:\n\n即设计一种反悔策略，使得随便一种念心策略都可以得到正解。\n基本的设计思路是：每次选择直观上最接近全局最优解的念心策略，若发现最优解不对，就想办法自动支持反悔策略。（这就是自动机的意思）\n和你在 Dinic 的过程中流走的流量要加到反向边上一个道理。\n具体题目具体分析。一般需要反悔自动机的题都是通过差值巧妙达到反悔的目的。\n\n反悔堆:\n\n即通过大/小根堆来维护当前贪心策略的最优解，若发现最优解不对，就退回上一步，更新最优解。\n由于堆的性质，使得堆的首数据一定是最优的，这就可以实现快速更新最优解。\n P4053 [JSOI2007] 建筑抢修\n简单题，好像你们都做过。\n 题意：\n你有nnn个建筑待修，每个建筑有一个修理时间T1T_1T1​表示修理所需要的时间，和截止时间T2T_2T2​，若在T2T_2T2​时刻结束时仍未修完，则该建筑报废。\n求你能修好的最大建筑数量。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n容易想到先按照T2T_2T2​从小往大排序，考虑如何决策。\n决策时如果能修就修，并将该建筑的T1T_1T1​加入大根堆里，若不能则与堆顶比较，若T1T_1T1​小于堆顶则撤销对堆顶的操作并取代，可以保证选择完的修理总时间最小。\n唐了，怎么选了道你们都会的题。\n有几道作业，CF的题尽量做吧，如果没号就算了。\n 前缀和&amp;差分：\n不是哥们\n在黑板上口胡口胡算了。\n 二分：\n思想就不再赘述，说一下写法。\n设mid=l+r2mid=\\frac{l+r}{2}mid=2l+r​，常用的写法是l←mid+1l\\leftarrow mid+1l←mid+1或r←midr\\leftarrow midr←mid。\n所以为了正确性需要保证在选择右区间时midmidmid不可取且在选择左区间时midmidmid可取。\n若不满足则需要微调，但注意不能直接写成 l←midl\\leftarrow midl←mid，因为会死循环（小数就爱怎么写怎么写）。\n例题黑板讲。\n CDQ 分治：\n黑板，全写下来太麻烦。\n 倍增：\n就是处理出 2 的幂来优化一些算法的复杂度。\n主要说说用法：\n\nRMQ，如 ST 表。\n求 LCA，不如树剖。\n求 k 级祖先，长剖 + 倍增 = nlognnlognnlogn预处理O(1)O(1)O(1)询问，这里不具体讲，因为后面有人讲长剖。\n\n 并查集：\n普通并查集：\n这个不用讲。\n可撤销并查集：\n首先我们不能再用路径压缩优化，因为会改变树的形态，所以选择启发式合并（即由小向大合并）。\n然后我们用一个栈存下加入的边，撤销时不断弹栈，将连边对象设为自己即可。\n可持久化并查集：\n哦，原来是主席树啊，留着吧。\n 对拍：\n我自己常用的对拍：\n#include &lt;bits/stdc++.h&gt;#include &lt;windows.h&gt;using namespace std;int main()&#123;    long long cnt = 0;    while (1)    &#123;        system(&quot;shuju.exe&quot;);        system(&quot;baoli.exe&quot;);        double time1 = clock() * 1.0 / CLOCKS_PER_SEC;        system(&quot;.exe&quot;);        double time2 = clock() * 1.0 / CLOCKS_PER_SEC;        if (!&quot;fc .out .ans&quot;)            return 0;        printf(&quot;Test%lld:\\nTime consumption: %.3lf\\nNo problem.\\n\\n&quot;, ++cnt, time2 - time1);    &#125;    return 0;&#125;\n1\n","categories":["课件"],"tags":["课件"]}]